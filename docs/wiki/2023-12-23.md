# VimEnter 2023

첫 번째 세션, 힘들고 빠르게 배우기 - 한윤석 코드숨 대표님.
vim 말고는 에디터 모두 제거하여 환경을 강제적으로 만듦.
"울트라러닝" 책에서 영감을 얻음
현재 커서의 테스트 함수를 실행하는 플러그인 등 직접 구현

---

두 번째 세션, front-end, 조성진, ts, lua
플러그인 소개에 대한 내용
lazy.nvim을 플러그인 매니저로 사용
toggleterm.nvim
c-\로 터미널 염. 특정 명령어로 고유 터미널 세션 관리. c-\는 항상 새로운 세션
tmux도 사용은 하나, 불편함이 있었음.
전용 명령어를 만드는 것은 다양하게 활용 가능. jira-cli를 이용한, 할당받은 task만 보는 터미널.
두 번째 플러그인은 alpha.nvim 초기화면 플러그인.
개발환경에 대해 생각하는 것
- 터미널에 가까운 것
- 필요한 만큼만 커스텀
- 필요하면 개선할 수 있어야 함
- 개발할수록 즐거움이 있어야 함

넷플릭스 vim 사용 개발자 유튜브

즐거움? 내가 만든 것을 잘 사용하면서 오는 뿌듯함. 과정은 그렇지 않았지만.

aud: which key 사용하는지?
" https://github.com/liuchengxu/vim-which-key 이거 인 듯?
speaker: telescope에서 keymap 제공해서 사용

---

3. johngrib. 나만의 vimwiki lsp 만들기

- 발표자료: https://johngrib.github.io/wiki/article/vimwiki-lsp/
- lsp project: https://github.com/johngrib/johngrib-wiki-lsp

vimwiki를 fork하여 사용 중. 기능을 줄이고, 추가하여 사용함
johngrib-wiki-lsp를 만들어서 사용중
lsp를 만든 이유. vimwiki 링크를 개선하고 싶다.
intellij와 소켓 통신을 통해서 kotlin 개발을 도와주는 플러그인에서 내가 개선할 수 있는 환경에 대한 요구사항이 있음
vim은 작은 코드 조각으로 vim에서 동작할 수 있는 것이 매력이었음. 그러나 vimscript는 아님.
lua도 익숙하지 않는 언어임. hammerspoon 등에서 사용 중.
chatgpt 도움을 받아서 구현하고, coc.nvim으로 연결하기 쉽겠다는 추정이 되었다.
vimscript lsp가 있으면 vim을 몰라도 사용할 수 있겠다는 추정.
다양한 문제점과 해결책을 정리해봄
vimwiki와 markdown 링크의 간극 문제
- 링크를 fzf, telescope로 찾아보고 등록하자.
- 나아가서 슬래시만 입력하면 링크를 찾자. LSP의 필요성
- LSP 심플한 튜토리얼이 있음. (블로그참고)
- 문서와 리소스 완성 등 lsp 기능을 만들었음
- vimwiki 문서 링크에 커서를 올리면 제목을 보여주는 기능.

---

4. windows unreal engine 개발자의 neovim - 이효승

unreal engine 개발 이전부터 사용해왔음
게임 엔진 자체가 매우 무거운 프로그램인데, 에디터까지 무거운 매우 불편한 환경이라 neovim으로 가벼운 에디팅 환경이 필요했다.
visual studio는 매우 무겁다. 다른 게임 엔진들도 visual studio 사용을 가정하고 tool chain이 제공된다.
neovim으로 UE에서 debug는 하지 않는다.
UE에서 neovim lsp 사용하는 것이 목표.

windows에서 neovim 설치부터 시작하자.
`winget` 사용. config는 `%AppData%`에 있음.
GUI 사용하는 편이 편리함. Neovim-QT. neovim 설치하면 기본으로 설치됨. neovide라는 선택지도 있다.
마우스 인터랙션 잘 됨
윈도우즈는 c빌드가 필요한 플러그인 설치함에 어려움 있음. 기본적인 도구가 제공되지 않기 때문. 따라서 별도 설치해야 한다.
developer command prompt for vs 2022 설치 필요.
telescope, treesitter 플러그인이 빌드가 필요함.
UE는 c++ 사용하므로 clang lsp 사용.

UE Project Setting
모듈 단위로 dll 생성하여 링크함. 모듈마다 dependency 관리됨.
엔진에서 자동으로 생성하는 소스 코드
PS, xbox 등 게임 플랫폼마다 달라지는 매크로들. 빌드 타켓에 따른 매크로.
Unreal Build Tool(UBT)라는 도구로 Compile DB 생성, clang lsp로 인덱싱하여 LSP 사용.
이제, UE가 제공하는 정의에 대해 접근할 수 있다.
인덱싱 매우 느림. 1만가지 심볼에 대해서 수십시간 소요.

결론: UE + neovim + clang 쓸만하지만 완벽하지 않다. neovim의 생산성이 좋다.
메인을 vs, 서브로 neovim 사용.

---

5. 트리시터로 나만의 플러그인 만들기. classy.nvim 제작 후기 - 차주훈 jcha0713

- https://github.com/jcha0713/classy.nvim
- https://github.com/nvim-treesitter/playground

트리시터는.. 구문 분석 framework. 점진적 구문 분석.
기존 IDE가 가진 문제점. 특정 언어에 특화된 기능, 파일 크기에 비례하는 하이라이트 등 처리 속도.
neovim 0.5 부터 tree-sitter 공식 지원.
LSP도 0.5부터 지원함. lsp는 프로젝트 범위에서 언어 기능을 위한 프로토콜.
tree-sitter는 하나의 버퍼에 대한 기능.
classy.nvim은 html "class" 속성을 제거, 닫은 태그에서 사용할 수 있고, html 외 파일에서도 동작하는 플러그인.
플러그인 제작에 영감받은 플러그인은 되지 않았다.
tree-sitter API를 이용하여 속성 추가, 제거 등 처리한다.
html과 jsx와 다른 부분을 이해해야 했음. jsx에서는 className을 사용.
tree-sitter 플러그인 개발하려면 treesitter/playground가 필요한데, 0.10 버전부터는 내장되어 별도 설치 필요 없음.
`:InspectTree`라는 명령어로 언어위에서 적용되는 treesitter 구문을 열 수 있음. 실시간 적용가능한 도구를 제공해서 유용.

---

6. neovim으로 생산성 퀀텀점프하기

이전 발표에서 이어지는 점.
내 workflow를 meovim으로 개선하자.
read, w, m, select, d로 우리가 하는 작업을 atomic 분해할 수 있겠다.
행동에서 소용되는 시간을 최적화 하자.
- 손을 움직이는 것을 줄이는 것
- 인지부하를 줄이는 것
- snippet 등으로 명령을 줄이기
의미론 단위로 일을 처리하면 단순화할 수 있다.

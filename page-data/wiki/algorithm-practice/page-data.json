{"componentChunkName":"component---src-pages-wiki-markdown-remark-fields-slug-tsx","path":"/wiki/algorithm-practice/","result":{"data":{"markdownRemark":{"headings":[{"value":"알고리즘 연습"}],"fields":{"relatedDocs":[{"slug":"javascript","similarity":0.7925662265},{"slug":"web","similarity":0.7691808082},{"slug":"2016-08-27-gdg-webtech-workshop-nnn","similarity":0.7632915942},{"slug":"crontab","similarity":0.7414870248},{"slug":"idea-methodology","similarity":0.7694615493},{"slug":"2016-11-16-google-campus-two-things-you-must-keep-in-google-play","similarity":0.7517486758},{"slug":"spring-framework","similarity":0.7038251942},{"slug":"aws","similarity":0.7407534669},{"slug":"git","similarity":0.7557930763},{"slug":"algorithm-practice","similarity":1},{"slug":"docker","similarity":0.7375012194},{"slug":"scp","similarity":0.7053306434},{"slug":"mac-os","similarity":0.7657576226},{"slug":"testing","similarity":0.7217455894},{"slug":"machine-learning","similarity":0.7708460964},{"slug":"devops","similarity":0.7659332117},{"slug":"python","similarity":0.7258695886},{"slug":"object-oriented-programming","similarity":0.7460822318},{"slug":"linux","similarity":0.7271317854},{"slug":"sfml","similarity":0.7225905735},{"slug":"windows","similarity":0.7399681795},{"slug":"markdown","similarity":0.7234939096},{"slug":"cat-logic","similarity":0.7583312311},{"slug":"vuejs","similarity":0.7229900867},{"slug":"shell","similarity":0.7454812491},{"slug":"html","similarity":0.748195298},{"slug":"data-analysis","similarity":0.7530177654},{"slug":"hardware","similarity":0.7223729473},{"slug":"programming-convention","similarity":0.732173269},{"slug":"webgl","similarity":0.7635181093},{"slug":"sentry","similarity":0.7193135418},{"slug":"valve","similarity":0.7443606651},{"slug":"reactjs","similarity":0.7689833651},{"slug":"airflow","similarity":0.7168539701},{"slug":"computer-graphics","similarity":0.7809264977},{"slug":"programming-philosophy","similarity":0.7609647899},{"slug":"elasticsearch","similarity":0.7341788354},{"slug":"unicode","similarity":0.7688061771},{"slug":"logging","similarity":0.734405225},{"slug":"tools","similarity":0.7412974228},{"slug":"programming-paradigm","similarity":0.7417109163},{"slug":"inspiration","similarity":0.7816010624},{"slug":"gatsbyjs","similarity":0.7361021176},{"slug":"design-pattern","similarity":0.7241168113},{"slug":"game","similarity":0.7325542009},{"slug":"kubernetes","similarity":0.7103171887},{"slug":"nodejs","similarity":0.7786885853},{"slug":"continuous-integration-and-deployment","similarity":0.736491501},{"slug":"rust","similarity":0.7116094625},{"slug":"book","similarity":0.8476483473},{"slug":"jetbrains","similarity":0.7373997935},{"slug":"quotation","similarity":0.7563666341},{"slug":"jira","similarity":0.724405885},{"slug":"swagger","similarity":0.6958491037},{"slug":"architecture","similarity":0.7568083187},{"slug":"unity3d","similarity":0.7375263994},{"slug":"jargon","similarity":0.7626343098},{"slug":"language-server-protocol","similarity":0.7228030409},{"slug":"clean-code","similarity":0.753646915},{"slug":"java","similarity":0.6944571539},{"slug":"windows-subsystem-for-linux","similarity":0.7387516937},{"slug":"test-driven-development","similarity":0.7493361301},{"slug":"github","similarity":0.701242073},{"slug":"network","similarity":0.738846753},{"slug":"kotlin","similarity":0.7350210902},{"slug":"c-sharp","similarity":0.7213525061},{"slug":"angularjs","similarity":0.7427335428},{"slug":"vim","similarity":0.7485510344},{"slug":"ionic-framework","similarity":0.7314564184},{"slug":"physics","similarity":0.7873382819},{"slug":"html-canvas","similarity":0.7325338416},{"slug":"reverse-engineering","similarity":0.7225186296},{"slug":"css","similarity":0.7507535171},{"slug":"code-review","similarity":0.7751623573},{"slug":"software-development","similarity":0.7560850204},{"slug":"database","similarity":0.762160091},{"slug":"reactive-extensions","similarity":0.6923497936},{"slug":"redis","similarity":0.7183233684},{"slug":"mail","similarity":0.7053276634},{"slug":"experience-review","similarity":0.7561751239},{"slug":"google-analytics","similarity":0.7516750422},{"slug":"data-structure","similarity":0.7612798635},{"slug":"vimwiki","similarity":0.7308162192}]},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%97%B0%EC%8A%B5\">알고리즘 연습</a></p>\n<ul>\n<li><a href=\"#%EB%95%85%EB%94%B0%EB%A8%B9%EA%B8%B0-%EA%B2%8C%EC%9E%84\">땅따먹기 게임</a></li>\n</ul>\n</li>\n</ul>","html":"<h1 id=\"알고리즘-연습\" style=\"position:relative;\"><a href=\"#%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%97%B0%EC%8A%B5\" aria-label=\"알고리즘 연습 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>알고리즘 연습</h1>\n<h2 id=\"땅따먹기-게임\" style=\"position:relative;\"><a href=\"#%EB%95%85%EB%94%B0%EB%A8%B9%EA%B8%B0-%EA%B2%8C%EC%9E%84\" aria-label=\"땅따먹기 게임 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>땅따먹기 게임</h2>\n<p><a href=\"https://programmers.co.kr/learn/challenge_codes/36\">https://programmers.co.kr/learn/challenge_codes/36</a></p>\n<blockquote>\n<p>영희는 땅따먹기 게임에 푹 빠졌습니다. 땅따먹기 게임의 땅은 총 N행 4열로 나누어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 땅을 밟으면서 한 행씩 내려올 때, 영희는 각 행의 4칸 중 1칸만 밟으면서 내려올 수 있습니다. 땅따먹기 게임에는 같은 열을 연속해서 밟을 수가 없는 특수 규칙이 있습니다. 즉, 1행에서 (5)를 밟았다면, 2행의 (8)은 밟을 수가 없게 됩니다. 마지막 행까지 모두 내려왔을 때, 점수가 가장 높은 사람이 게임의 승자가 됩니다. 여러분이 hopscotch 함수를 제작하여 영희가 최대 몇 점을 얻을 수 있는지 알려주세요. 예를 들어</p>\n</blockquote>\n<p>1 2 3 5 5 6 7 8 4 3 2 1 의 땅이 있다면, 영희는 각 줄에서 (5), (7), (4) 땅을 밟아 16점을 최고점으로 받을 수 있으며, hopscotch 함수에서는 16을 반환해주면 됩니다.</p>\n<pre><code class=\"language-javascript\">function hopscotch(board, size) {\n    var result = 0;\n    // 함수를 완성하세요.\n\n    return result;\n}\n\n //아래는 테스트로 출력해 보기 위한 코드입니다.\nvar board = [[ 1, 2, 3, 5 ], [ 5, 6, 7, 8 ], [ 4, 3, 2, 1]];\nconsole.log(hopscotch(board, 3));\n</code></pre>\n<hr>\n<p>처음 생각한 방법은 모든 경우의 수를 찾는 것이었다.</p>\n<p>다음 행으로 넘어갈 때 마다 모든 경우에 대한 합을 저장하는 방법을 사용했다.</p>\n<pre><code class=\"language-javascript\">// 시작 (1행)\n[1, 2, 3, 5]\n// 2행\n// - 7, 8, 9 : 첫 행 1에서 시작할 때 모든 경우의 합: (+6, +7, +8)\n// - 7, 9, 10 : 첫 행 2에서 시작할 때 모든 경우의 합: (+5, +7, +8)\n// - ...\n[\n    7, 8, 9,\n    7, 9, 10,\n    8, 9, 11,\n    10, 11, 12]\n// 이하 마찬가지\n</code></pre>\n<p>문제는 다음 행으로 넘어갈 수록 계산 횟수가 기하급수적으로 늘어난다는 것이다.</p>\n<p>2행 순회의 경우 4 * (4 - 1) = 12의 계산 수를 통해 12크기의 배열이 만들어진다.</p>\n<p>3행 순회할 때는 12 * (4 - 1) = 36 ...</p>\n<p>끝까지 순회할 때의 모든 경우의 수를 다 저장하는 방법은 순회할 때마다 기하급수적으로 계산 횟수가 늘어나는 것이다.</p>\n<p>생각해보니 모두 저장할 필요 없이 <strong>각 행에 도착할 때마다 각 자리에 올 수 있는 가장 큰 값만 저장</strong>하면 되었다.</p>\n<p>예를들어 :</p>\n<p>2행에서 올 수 있는 가장 큰 값은 <code>5 + 5</code>, <code>5 + 6</code>, <code>5 + 7</code>, <code>3 + 8</code> => <code>[10, 11, 12, 11]</code></p>\n<p>3행에서 올 수 있는 가장 큰 값은 <code>12 + 4</code>, <code>12 + 3</code>, <code>11 + 2</code>, <code>12 + 1</code> => <code>[16, 15, 13, 13]</code></p>\n<p>따라서 매 행마다 고정된 계산 횟수만으로 답 <code>16</code>을 구할 수 있다.</p>\n<hr>\n<p>풀이:</p>\n<pre><code class=\"language-javascript\">function hopscotch(board, size) {\n  const final = board.reduce((scores, row) => {\n    const newScores = [];\n    scores.forEach((score, iscore) => {\n      row.forEach((v, iv) => {\n        if (iv === iscore) return;\n        if (!newScores[iv]) newScores[iv] = [];\n        newScores[iv].push(score + v);\n      });\n    });\n    return newScores.map(scores => Math.max(...scores));\n  });\n  return Math.max(...final);\n}\n\n //아래는 테스트로 출력해 보기 위한 코드입니다.\nvar board = [[ 1, 2, 3, 5 ], [ 5, 6, 7, 8 ], [ 4, 3, 2, 1]];\nconsole.log(hopscotch(board, 3));\n</code></pre>"}},"pageContext":{"id":"6d96cf13-6b2d-57cc-aa84-86312e8e5764","fields__slug":"/algorithm-practice/","__params":{"fields__slug":"algorithm-practice"}}},"staticQueryHashes":[],"slicesMap":{}}
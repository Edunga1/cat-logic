{"componentChunkName":"component---src-pages-wiki-markdown-remark-id-tsx","path":"/wiki/262dba00-9c14-539c-9518-03de37e6b4dc/","result":{"data":{"markdownRemark":{"id":"262dba00-9c14-539c-9518-03de37e6b4dc","tableOfContents":"<ul>\n<li>\n<p><a href=\"#design-pattern\">Design Pattern</a></p>\n</li>\n<li>\n<p><a href=\"#iterator-pattern\">Iterator Pattern</a></p>\n</li>\n<li>\n<p><a href=\"#repository-pattern\">Repository Pattern</a></p>\n<ul>\n<li><a href=\"#generic-repository-vs-specific-repository\">Generic Repository vs. Specific Repository</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#state-pattern-and-state-machine\">state pattern and state machine</a></p>\n<ul>\n<li>\n<p><a href=\"#state-pattern\">state pattern</a></p>\n</li>\n<li>\n<p><a href=\"#state-machine\">state machine</a></p>\n<ul>\n<li>\n<p><a href=\"#%EA%B5%AC%ED%98%84%EC%B2%B4\">구현체</a></p>\n<ul>\n<li><a href=\"#spring\">Spring</a></li>\n<li><a href=\"#pytohn\">Pytohn</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#references\">references</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#strategy-pattern\">Strategy Pattern</a></p>\n</li>\n<li>\n<p><a href=\"#mvc-pattern\">MVC Pattern</a></p>\n<ul>\n<li>\n<p><a href=\"#mvc-%ED%8C%A8%ED%84%B4%EC%9D%98-%EB%AA%A9%EC%A0%81%EA%B3%BC-%EC%9D%B4%EC%A0%90\">MVC 패턴의 목적과 이점</a></p>\n</li>\n<li>\n<p><a href=\"#compound-pattern\">Compound Pattern</a></p>\n<ul>\n<li><a href=\"#1-observer-pattern\">1. Observer Pattern</a></li>\n<li><a href=\"#2-strategy-pattern\">2. Strategy Pattern</a></li>\n<li><a href=\"#3-composite-pattern\">3. Composite Pattern</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EC%A1%B0\">참조</a></p>\n</li>\n</ul>","html":"<h1>Design Pattern</h1>\n<h1>Iterator Pattern</h1>\n<p>다양한 Collection을 일관적인 방법으로 순회할 수 있도록 함</p>\n<p><img src=\"res/dp-iterator.gif\" alt=\"uml-iterator\"></p>\n<p>Java의 경우 ArrayList, Vector, LinkedList와 같은 컬렉션 클래스들은 java.util.Iterator를 구현하여\niterator() 메소드를 통해 iterator를 반환 해 준다.</p>\n<p>일반 배열을 사용한 경우 Iterator 인터페이스를 구현한 Concrete Iterator를 만들어서 사용하면 된다.</p>\n<h1>Repository Pattern</h1>\n<p>도메인 로직에서 저장소에 접근하기 위해서 쿼리를 전송하는 것은 좋지 않다. 특정 데이터베이스에 종속된다.\nRDBMS도 MySQL, MsSQL, Oracle 다 쿼리 스펙이 다르다. 그래서 데이터 소스(DB)와 커뮤니케이션할 추상 레이어를 둔다.\n데이터베이스의 변경 여지가 있기 때문에 추상화하기도 한다. MySQL -> MsSQL 전환, RDBMS -> NoSQL로의 전환도 언젠가 할지도 모른다.</p>\n<p>물론 DB 전환을 염두하고 추상화하지 말라는 뉘앙스의 글도 있다: <a href=\"c9875c187a06ca42d069474cd880a901.md\">\"Database Abstraction Layers Must Die!\"라는 글을 읽고</a></p>\n<p>아무튼. Repository Pattern은 데이터의 중앙화와 API의 일관성을 유지하고 중복 코드를 제거해 준다.</p>\n<p><a href=\"https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ff649690(v=pandp.10)\">MSDN의 Repository Pattern</a>을 번역한 글:<br>\n<a href=\"http://vandbt.tistory.com/27\">http://vandbt.tistory.com/27</a></p>\n<p>개념적인 글이라서 코드가 있는 MSDN 글과 보면 좋다:<br>\n<a href=\"https://docs.microsoft.com/ko-kr/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application\">https://docs.microsoft.com/ko-kr/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application</a></p>\n<p>UnitOfWork 패턴까지 이어지는 글이다.</p>\n<p>Repository Pattern에는 두 종류가 있다. Generic Repository와 Specific Repository</p>\n<p>코드 중복을 제거하고 일관성 유지를 강조하는 Generic Repository와 유연성을 강조하는 Specific Repository.</p>\n<h2>Generic Repository vs. Specific Repository</h2>\n<p><a href=\"https://stackoverflow.com/questions/1230571/advantage-of-creating-a-generic-repository-vs-specific-repository-for-each-obje\">https://stackoverflow.com/questions/1230571/advantage-of-creating-a-generic-repository-vs-specific-repository-for-each-obje</a></p>\n<ul>\n<li>점수를 많이 받은 답은 <strong>Specific Repository를 더 선호한다</strong>. 그 이유는 아래와 같다.</li>\n<li>모든 엔티티가 저장소를 가지는 것은 아니기 때문이다.</li>\n<li>하지만 베이스 레포지토리 (abstract class)는 사용한다.</li>\n<li>a repository is a part of the domain being modeled, and that domain is not generic. Not every entity can be deleted, not every entity can be added, not every entity has a repository<br></li>\n</ul>\n<p>레포지토리는 모델링 되는 도메인의 일부분이며, 그 도메인은 generic 하지 않다. 모든 엔티티가 삭제되거나 추가되는 것이 아니며, 모든 엔티티가 레파지토리를 가지는 것은 아니다.</p>\n<p><strong>Generic Repository?</strong></p>\n<ul>\n<li>Repository를 규격화 한다.</li>\n<li><code>Repository&#x3C;User></code>, <code>Repository&#x3C;Comment></code> 처럼 Entity 클래스를 Generic Type으로 받는다.</li>\n<li>장점으로 모든 Repository는 일관된 인터페이스를 가진다.</li>\n</ul>\n<p><strong>Specific Repository?</strong></p>\n<ul>\n<li>Repository를 테이블마다 구현한다.\n<ul>\n<li>UserRepository, CommentRepository</li>\n</ul>\n</li>\n<li>CRUD 뿐만 아니라 테이블별 각각 다른 메소드를 구현할 수 있다.\n<ul>\n<li>UserRepository.addUser, CommentRepository.deleteShortComment 처럼..</li>\n</ul>\n</li>\n<li>코드 양은 많아 지겠지만 Generic 보다 더 유연할 듯하다.</li>\n</ul>\n<p><strong>생각해 본 것들:</strong></p>\n<p><strong>대표적으로 C#의 Entity Framework. 대부분 DB 프레임워크는 어노테이션을 이용한다.</strong></p>\n<pre><code class=\"language-csharp\">public class Blog\n{\n    [Key]\n    public int PrimaryTrackingKey { get; set; }\n    public string Title { get; set; }\n    public string BloggerName { get; set;}\n    public virtual ICollection&#x3C;Post> Posts { get; set; }\n}\n</code></pre>\n<p>내가 위 코드를 동작케 한다면 다음과 같은 규칙을 가질 것이다:</p>\n<ol>\n<li>프로퍼티 이름 = 테이블 컬럼 이름</li>\n<li><code>[Key]</code> 어노테이션은 Primary Key가 되는데, 데이터베이스 PK, Unique, Auto increment 속성을 가진다.</li>\n<li>언어의 타입 int, string 등을 데이터베이스 타입에 적절히 매핑해야 함</li>\n</ol>\n<p>만약 어노테이션을 사용하지 않고, 자바스크립트로 구현한다면?</p>\n<ol>\n<li>프로퍼티 이름 = 테이블 컬럼 이름은 가능</li>\n<li>PK가 될 컬럼(프로퍼티)는 어떻게?</li>\n<li>타입은 어떻게 하나.</li>\n</ol>\n<p>위 문제를 해결하기 위해서 static 변수에 pk, type 등 정보를 저장해야 할 거 같다.</p>\n<p><strong>Specific Repository를 구현한다면 어노테이션 없이도 복잡하지 않게 구현할 수 있을 거 같다.</strong></p>\n<p>각 메서드에서 쿼리를 만들 거고(쿼리 빌더를 쓰던간에), 어노테이션 없는 Entity 클래스도 만들 수 있다!</p>\n<h1>state pattern and state machine</h1>\n<p>공통점은 많은 상태들 사이에서 같은 이벤트가 발생했을 때 다음 상태로 전이하는 것이다.</p>\n<p>다른 점은 어디에 집중하느냐 인데, state pattern은 이벤트에 따른 행동에, state machine은 상태 관리라고 생각한다.</p>\n<h2>state pattern</h2>\n<ul>\n<li>behavior의 구현에서 다음 상태를 결정하기 때문에, dynamic target 상태를 가진다.</li>\n<li>OOP로 구현하면 각 상태에 해당하는 concrete class가 존재한다.</li>\n<li>따라서 많은 상태와 행동이 있으면 관리하기 어렵다.</li>\n</ul>\n<h2>state machine</h2>\n<ul>\n<li>상태와 이벤트 조합으로 다음 상태(target)로 변화하는 transition을 한 곳에서 관리한다. 그래서 추적하기 쉽다.</li>\n<li>OOP로 구현하면 모든 상태를 관리하는 state machine로 일반화 했기 때문에 좀 더 간단하다.</li>\n<li>하지만 일반화 했기 때문에 이벤트마다 달라지는 부분을 구현하기에 까다롭다.</li>\n</ul>\n<h3>구현체</h3>\n<h4>Spring</h4>\n<p><a href=\"https://docs.spring.io/spring-statemachine/docs/1.1.1.RELEASE/reference/htmlsingle/\">https://docs.spring.io/spring-statemachine/docs/1.1.1.RELEASE/reference/htmlsingle/</a></p>\n<p>빌더 패턴으로 상태와 이벤트와 다음 상태를 구성한다.</p>\n<p>상태와 하위 상태까지 구성 가능하다.</p>\n<h4>Pytohn</h4>\n<p><a href=\"https://github.com/pytransitions/transitions\">https://github.com/pytransitions/transitions</a></p>\n<h2>references</h2>\n<p><a href=\"https://stackoverflow.com/questions/19859531/what-is-the-difference-between-a-state-machine-and-the-implementation-of-the-sta\">https://stackoverflow.com/questions/19859531/what-is-the-difference-between-a-state-machine-and-the-implementation-of-the-sta</a></p>\n<p>답변자 말로는, state pattern은 분산된 구조이고, state machine은 모놀리틱 구조라 한다.</p>\n<h1>Strategy Pattern</h1>\n<p><a href=\"https://refactoring.guru/ko/design-patterns/strategy\">refactoring.guru</a>중에서:</p>\n<blockquote>\n<ol start=\"4\">\n<li>콘텍스트 클래스에서 전략 객체에 대한 참조를 저장하기 위한 필드를 추가한 후, 해당 필드의 값을 대체하기 위한 세터를 제공하세요. 콘텍스트는 전략 인터페이스를 통해서만 전략 객체와 작동해야 합니다. 콘텍스트는 인터페이스를 정의할 수 있으며, 이 인터페이스는 전략이 콘텍스트의 데이터에 접근할 수 있도록 합니다.</li>\n</ol>\n</blockquote>\n<p>간단히 전략 객체 내에서 print만하는 예제들이 놓치는 부분이다.</p>\n<p>전략 객체는 context가 제공하는 메서드를 사용하여 context를 변경해야한다.\n전략 객체의 메서드에서 파라미터로 받거나, 생성자로 받거나 할 필요가 없다.</p>\n<h1>MVC Pattern</h1>\n<p>Model - View - Controller Pattern.</p>\n<h2>MVC 패턴의 목적과 이점</h2>\n<p>MVC 패턴는 사용자 인터페이스와 시스템 로직을 분리하는 것을 목적으로 둔다.</p>\n<p>분리함으로써 얻는 이점은 다른 환경에서 재사용 할 수 있는 코드가 생기는 것이다.</p>\n<p>예를들어 C# 윈도우 어플리케이션에 종속되는 유저 인터페이스 관련 코드들과 시스템이 돌아가는데\n필요한 코드(model)를 분리함으로써 다른 플랫폼으로 이식할 수 있다.</p>\n<h2>Compound Pattern</h2>\n<p>MVC 패턴은 다른 디자인 패턴으로 이루어진 컴파운드 패턴이다.</p>\n<h3>1. Observer Pattern</h3>\n<p>Model - View의 관계</p>\n<p>유저 인터페이스와 시스템 로직을 분리할 수 있게 해주는 핵심 패턴으로 모델은 상태 변경이 일어나면\n뷰에 상태 변경을 통보한다.</p>\n<p>그러면 뷰는 모델에서 필요한 정보들을 가져와 사용자 화면을 업데이트 한다.</p>\n<p>모델이 뷰에 통보할 때 상태 정보를 보내주는 push-model 보다\n통보 후 뷰가 필요한 정보를 알아서 가져가는 pull-model이 더 선호된다.</p>\n<h3>2. Strategy Pattern</h3>\n<p>View - Controller의 관계</p>\n<p>Controller는 View에 대한 Behavior가 된다.</p>\n<p>같은 View라고 하더라도 Controller를 변경함으로써 다르게 실행되도록 할 수 있다.</p>\n<p>따라서 View에 Concrete Controller가 아닌 Interface Controller를 제공한다.</p>\n<h3>3. Composite Pattern</h3>\n<p>View 내에서 Component들 간의 관계</p>\n<p>일반적으로 사용자 인터페이스의 컴포넌트들은 컴포넌트 안에 컴포넌트로 표현한다.</p>\n<p>이 컴포넌트들을 iterator를 통해 일관성있게 접근하여 업데이트 시킨다.</p>\n<h1>참조</h1>\n<ul>\n<li><a href=\"https://refactoring.guru/ko/design-patterns/\">refactoring.guru</a> - 무료 공개 ebook</li>\n</ul>"}},"pageContext":{"id":"262dba00-9c14-539c-9518-03de37e6b4dc","__params":{"id":"262dba00-9c14-539c-9518-03de37e6b4dc"}}},"staticQueryHashes":[],"slicesMap":{}}
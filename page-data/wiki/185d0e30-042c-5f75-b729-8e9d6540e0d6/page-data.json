{"componentChunkName":"component---src-pages-wiki-markdown-remark-id-tsx","path":"/wiki/185d0e30-042c-5f75-b729-8e9d6540e0d6/","result":{"data":{"markdownRemark":{"id":"185d0e30-042c-5f75-b729-8e9d6540e0d6","tableOfContents":"<ul>\n<li>\n<p><a href=\"#testing\">Testing</a></p>\n</li>\n<li>\n<p><a href=\"#setup-and-teardown\">Setup and Teardown</a></p>\n<ul>\n<li><a href=\"#transaction-start---rollback\">Transaction Start - Rollback</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#better-specs\">Better Specs</a></p>\n<ul>\n<li><a href=\"#single-expectation%EB%8B%A8%EC%9D%BC-%EA%B2%80%EC%A6%9D\">Single Expectation(단일 검증)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%99%9C-%EC%9C%A0%EB%8B%9B-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-%EC%9D%98%EC%A1%B4%EC%84%B1%EC%9D%84-%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A4%91%EC%9A%94%ED%95%9C%EA%B0%80%EC%9A%94\">왜 유닛 테스트에서 의존성을 테스트하지 않는 것이 중요한가요?</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9C%A0%EB%8B%9B-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-%EC%83%81%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%88%EC%84%B8%EC%9A%94\">유닛 테스트에서 상수를 사용하지 마세요.</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%9C%A0%EB%8B%9B-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%97%90%EC%84%9C-damp-not-dry%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%9D%98%EB%AF%B8%ED%95%98%EB%82%98%EC%9A%94\">유닛 테스트에서 \"DAMP not DRY\"는 무엇을 의미하나요?</a></p>\n</li>\n</ul>","html":"<h1>Testing</h1>\n<h1>Setup and Teardown</h1>\n<p>각 테스트를 실행하기 전/후 할 일을 각각 <strong>Setup</strong> <strong>Teardown</strong> 이라한다.</p>\n<h2>Transaction Start - Rollback</h2>\n<p>데이터베이스를 Mocking 하지 않고 테스트용 데이터베이스를 띄운다고 가정한다.</p>\n<p>일반적으로 테스트는</p>\n<ol>\n<li>DB에 데이터를 입력 - 이러한 데이터가 주어졌을 때 (GIVEN)</li>\n<li>API, 함수를 실행 - 테스트하고자 하는 기능 실행 (WHEN)</li>\n<li>데이터의 변경/반환 확인 (THEN)</li>\n</ol>\n<p>위 과정을 거친다.</p>\n<p>테스트를 하면서 사용한 데이터를 다시 제거하지 않으면, 다음 테스트에 영향을 미치게 된다.\n이를 해결하기 위해서 Setup에서 <code>TRANSACTION START</code>, Teardown에서 <code>ROLLBACK</code> 하면\nDB 상태를 다시 복구할 수 있다.</p>\n<p>트랜잭션을 사용하지 않고, <code>DELETE FROM</code> DDL을 통하여 데이터를 삭제할 수도 있으나,\n테스트를 중간에 멈췄을 때 상태를 복구할 수 없다.\n또, 트랜잭션은 최소한의 안정장치가 될 수 있을 거 같다.\n잘못 입력한 데이터베이스 URL을 대응할 수 있지 않을까.</p>\n<p>Django는 테스트 시 데이터 삭제 여부에 대한 옵션이 있다:<br>\n<a href=\"https://docs.djangoproject.com/en/2.2/topics/testing/advanced/#django-db-connection-creation\">https://docs.djangoproject.com/en/2.2/topics/testing/advanced/#django-db-connection-creation</a></p>\n<p>Spring에서 테스트에 <code>@Transactional</code> 사용하지 말 것을 설명하는 글도 있다:<br>\n<a href=\"https://dev.to/henrykeys/don-t-use-transactional-in-tests-40eb\">Don’t Use @Transactional in Tests</a></p>\n<p>테스트에 <code>@Transactional</code>을 붙이면 위와 테스트를 트랜잭션으로 묶을 수 있다. 하지만 그러면서 발생하는 문제점도 있다.</p>\n<ul>\n<li><a href=\"https://ko.wikipedia.org/wiki/%EA%B1%B0%EC%A7%93_%EC%96%91%EC%84%B1%EA%B3%BC_%EA%B1%B0%EC%A7%93_%EC%9D%8C%EC%84%B1\">false negative</a>으로 테스트를 망침</li>\n<li>운영코드에는 버그가 있지만, 테스트에서 성공하는 것을 <strong>false negative</strong> 라고한다.</li>\n<li>이는 개발자의 테스트에 대한 신뢰도 감소로 이어진다. 테스트를 덜 작성하게 될 것이다.</li>\n<li>직접 테스트하지 않는 이상 발견할 수 없는 버그가 운영 코드에 포함된다.</li>\n</ul>\n<p>글에서 설명하는 false negative 예제: 운영 코드에는 <code>@Transactional</code> 빠졌지만, 테스트에는 있어서 성공하고, 직접 호출하면 실패한다.</p>\n<h1>Better Specs</h1>\n<p><a href=\"https://www.betterspecs.org/\">https://www.betterspecs.org/</a></p>\n<blockquote>\n<p>Better Specs is a collection of best practices developers learned while testing apps that you can use to improve your coding skills, or simply for inspiration. Better Specs came to life at Lelylan (open source IoT cloud platform) and checking out its test suite may be of inspiration.</p>\n</blockquote>\n<p>Better Specs는 테스트 작성에 대한 모범 사례(best practice) 모음이다.</p>\n<p>사이트에서 소개하는 예시는 Rails의 RSpec을 사용하지만, 다른 언어/프레임워크에서도 적용하는 것을 목표로 한다.</p>\n<h2>Single Expectation(단일 검증)</h2>\n<p><a href=\"https://www.betterspecs.org/#single\">https://www.betterspecs.org/#single</a></p>\n<pre><code class=\"language-ruby\">it { is_expected.to respond_with_content_type(:json) }\nit { is_expected.to assign_to(:resource) }\n</code></pre>\n<p>한 번에 하나만 검증하는 것은 가독성, 테스트 실패 시 원인 파악이 쉽다는 장점이 있다.\n하지만 DB 등 호출 비용이 큰 경우에는 여러 개를 한 번에 검증하는 것도 허용한다.</p>\n<pre><code class=\"language-ruby\">it 'creates a resource' do\n  expect(response).to respond_with_content_type(:json)\n  expect(response).to assign_to(:resource)\nend\n</code></pre>\n<p>관련 SO 질문이 있다: <a href=\"https://softwareengineering.stackexchange.com/q/7823\">Is it OK to have multiple asserts in a single unit test?</a></p>\n<p>답변 채택은 single expectation을 권장하고 테스트를 작성하다보면 결국 하나의 검증만 하게 될거라는 것.\n하지만 더 많은 추천을 받은 답변은 multiple expectation을 하는 것이다.</p>\n<p><a href=\"http://wiki.c2.com/?ArrangeActAssert\">Arrange, Act, Assert</a>패턴에 따라, 동일한 동작에 대한 여러 검증을 볼 수 있어서 좋다는 것.\n그러나 에러 문구가 상세하지 않다는 것은 인지하고 있어야 한다.</p>\n<h1>왜 유닛 테스트에서 의존성을 테스트하지 않는 것이 중요한가요?</h1>\n<p><a href=\"https://softwareengineering.stackexchange.com/questions/65477/why-is-it-important-that-a-unit-test-not-test-dependencies\">(Why) is it important that a unit test not test dependencies?</a></p>\n<p>Stackexchange의 질문:</p>\n<ul>\n<li>의존성을 테스트하지 말고, 검증 대상만 테스트하는 것이 중요하다고 한다.</li>\n<li>내 생각은 의존성을 테스트하는 것을 피하기 위해서, Mocking/Stubbing 하는 것은 테스트의 복잡성을 증가 시킨다.</li>\n</ul>\n<p>답변:</p>\n<ul>\n<li>이건 단어 정의 문제다.</li>\n<li>의존성까지 테스트하는 것은 Integration Test. unit test가 아니라 통합 테스트에 대해서 말한 것으로 보인다.</li>\n<li>통합 테스트는 오래 걸리기 때문에 빌드 프로세스에 포함하지 않을 수도 있다.</li>\n<li>우리 제품은.. 매 빌드마다 유닛 테스트를 돌리는데 몇 초가 걸리고, 매 check-in 마다 통합 테스트를 돌리는데 10분 정도가 걸리고, 매일 밤 완전(full)-통합 테스트를 돌리는데 4시간이 걸린다.</li>\n</ul>\n<p>될 수 있다면 mock 객체를 전달하는 편이 낫다. 그렇지 않으면 의존성이 반환하는 다양한 경우를 모두 테스트하는 욕구에 빠진다. 의존성의 테스트에서 중복되는 문제도 있다.</p>\n<h1>유닛 테스트에서 상수를 사용하지 마세요.</h1>\n<p><a href=\"https://dev.to/scottshipp/don-t-use-non-test-constants-in-unit-tests-3ej0\">Don't use non-test constants in unit tests</a></p>\n<blockquote>\n<p>Tests will pass when the code is wrong</p>\n<p>More importantly, tests that reference production constants can cause a situation where the code is actually wrong but the unit test passes anyway.</p>\n<p>Consider the case where there's a misspelling in \"Fizz\" or even the wrong value, as here where it has the value \"Buzz\":</p>\n<p>public class FizzBuzz {\npublic static final String FIZZ = \"Buzz\";\n// . . .</p>\n<p>The unit test will still pass, because the test is referencing against the same wrong <code>FizzBuzz.FIZZ</code> variable that the production code is referencing.</p>\n</blockquote>\n<p>테스트가 프로덕션 상수를 참조하면, 실제로 코드가 잘못되어도 테스트는 통과할 수 있다.\n<code>FizzBuzz.FIZZ</code> 변수를 참조하기 때문에 프로덕션 코드가 참조하는 것과 같은 잘못된 값으로 테스트가 통과할 수 있다.</p>\n<p>덧글 중:</p>\n<blockquote>\n<p>There's a third one, readability. Like you say, re-use is good, and if done right you can argue it's readable. However, in a test you need to know EXACTLY what the test is doing right there and then.</p>\n</blockquote>\n<p>가독성 측면에서도 상수를 테스트에서 사용하지 않는 것이 좋다고 한다.</p>\n<h1>유닛 테스트에서 \"DAMP not DRY\"는 무엇을 의미하나요?</h1>\n<p>SO 질문: <a href=\"https://stackoverflow.com/questions/6453235/what-does-damp-not-dry-mean-when-talking-about-unit-tests\">https://stackoverflow.com/questions/6453235/what-does-damp-not-dry-mean-when-talking-about-unit-tests</a></p>\n<ul>\n<li>DAMP: Descriptive And Meaningful Phrases. 설명적이고 의미 있는 구문을 사용하는 것. 코드의 가독성을 높여준다.</li>\n<li>DRY: Don't Repeat Yourself. 반복하지 않는 것.</li>\n</ul>\n<p>답변 중:</p>\n<blockquote>\n<p>It's a balance, not a contradiction</p>\n</blockquote>\n<p>테스트코드는 둘 사이에 균형을 잡아야 한다.</p>\n<blockquote>\n<p><strong>DAMP (Descriptive And Meaningful Phrases) promotes the readability of the code.</strong></p>\n<p>To maintain code, you first need to understand the code. To understand it, you have to read it. Consider for a moment how much time you spend reading code. It's a lot. DAMP increases maintainability by reducing the time necessary to read and understand the code.</p>\n</blockquote>\n<p>코드를 유지보수하려면 먼저 코드를 이해해야 한다. 이해하려면 읽어야한다. 코드를 읽는데 얼마나 많은 시간을 할애하는지 생각해보자.\nDAMP는 코드를 읽고 이해하는데 필요한 시간을 줄여 유지보수성을 높인다.</p>\n<blockquote>\n<p>So, why is duplication more acceptable in tests?</p>\n</blockquote>\n<p>테스트는 동일한 항목을 반복하기 때문에 중복이 더 허용된다.</p>\n<p>답변의 덧글 중:</p>\n<blockquote>\n<p>DRYing out test code has the potential to create an obscure test by introducing a <a href=\"http://xunitpatterns.com/Obscure%20Test.html#Mystery%20Guest\">mystery guest</a></p>\n</blockquote>\n<p>테스트 코드를 DRY하면, 모호한 테스트를 만들게 되어 mystery guest가 발생하게 된다.</p>\n<p>mystery guest: 테스트를 읽는 사람이 Fixture와 Verification 로직이 테스트 메서드 외부에서 동작하여 이해할 수 없게 되는 것.</p>"}},"pageContext":{"id":"185d0e30-042c-5f75-b729-8e9d6540e0d6","__params":{"id":"185d0e30-042c-5f75-b729-8e9d6540e0d6"}}},"staticQueryHashes":[],"slicesMap":{}}
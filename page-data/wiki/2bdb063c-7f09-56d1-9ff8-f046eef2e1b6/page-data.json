{"componentChunkName":"component---src-pages-wiki-markdown-remark-id-tsx","path":"/wiki/2bdb063c-7f09-56d1-9ff8-f046eef2e1b6/","result":{"data":{"markdownRemark":{"id":"2bdb063c-7f09-56d1-9ff8-f046eef2e1b6","tableOfContents":"<ul>\n<li>\n<p><a href=\"#node-js\">Node JS</a></p>\n</li>\n<li>\n<p><a href=\"#nodejs-test-tools\">NodeJS Test Tools</a></p>\n<ul>\n<li><a href=\"#mocha---framework\">Mocha - Framework</a></li>\n<li><a href=\"#chai---library\">Chai - Library</a></li>\n<li><a href=\"#istanbul---coverage-tool\">Istanbul - Coverage Tool</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#proxyquire\">Proxyquire</a></p>\n<ul>\n<li>\n<p><a href=\"#proxyquire-%EB%AA%A8%EB%93%88-%EB%A1%9C%EB%93%9C-%EC%88%9C%EC%84%9C-%EB%AC%B8%EC%A0%9C\">proxyquire 모듈 로드 순서 문제</a></p>\n<ul>\n<li><a href=\"#requireproxyquirenopreservecache-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\"><code>require('proxyquire').noPreserveCache()</code> 사용하기</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#proxyquire-vs-rewire\">Proxyquire vs. rewire</a></p>\n<ul>\n<li>\n<p><a href=\"#%EC%96%B4%EB%96%A4-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EC%9E%88%EC%9D%84%EA%B9%8C\">어떤 차이가 있을까?</a></p>\n<ul>\n<li><a href=\"#rewire-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8C%80%EC%83%81-%EB%82%B4%EC%97%90-%EC%84%A0%EC%96%B8%ED%95%9C-%EB%B3%80%EC%88%98%EB%A5%BC-%EA%B0%80%EB%A1%9C%EC%B1%84%EC%96%B4-%EB%B0%94%EA%BE%BC%EB%8B%A4\">rewire: 테스트 대상 내에 선언한 변수를 가로채어 바꾼다.</a></li>\n<li><a href=\"#proxyquire-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8C%80%EC%83%81%EC%9D%B4-require%ED%95%98%EB%8A%94-%EB%AA%A8%EB%93%88%EC%9D%84-%EB%B0%94%EA%BF%94%EC%84%9C-%EB%B3%B4%EB%82%B4%EC%A4%80%EB%8B%A4\">proxyquire: 테스트 대상이 <code>require</code>하는 모듈을 바꿔서 보내준다.</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#rewire-%EC%A0%9C%ED%95%9C%EC%82%AC%ED%95%AD\">rewire 제한사항</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#sinonjs\">Sinon.JS</a></p>\n<ul>\n<li><a href=\"#new-date-%EC%A1%B0%EC%9E%91%ED%95%98%EA%B8%B0\"><code>new Date()</code> 조작하기</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#nodejs-data-validation\">NodeJS data validation</a></p>\n</li>\n<li>\n<p><a href=\"#nodejs-%EC%84%9C%EB%B2%84-%EB%A1%9C%EC%BB%AC-%EC%9A%94%EC%B2%AD%EB%A7%8C-%ED%97%88%EC%9A%A9%ED%95%98%EA%B8%B0\">NodeJS 서버 로컬 요청만 허용하기</a></p>\n</li>\n<li>\n<p><a href=\"#pm2-deploy-%EC%8B%9C-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90\">pm2 deploy 시 주의할 점</a></p>\n</li>\n<li>\n<p><a href=\"#jupyter-notebook-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">Jupyter notebook 사용하기</a></p>\n</li>\n<li>\n<p><a href=\"#taming-architecture-complexity-in-v8\">Taming architecture complexity in v8</a></p>\n</li>\n</ul>","html":"<h1>Node JS</h1>\n<p>node.js로 개발을 하고있지 않아서.. 대부분 내용이 2016년 정도에 머물러 있다.</p>\n<h1>NodeJS Test Tools</h1>\n<p>지금은 <a href=\"https://github.com/facebook/jest\">Jest</a>를 사용하고 있다.\n이거 하나면 대부분 가능하더라.</p>\n<h2>Mocha - Framework</h2>\n<p>테스트 구조를 제공한다.</p>\n<p>설치 : <code>npm install mocha --save-dev</code></p>\n<p>테스트 스크립트 실행 : <code>mocha &#x3C;PATH></code></p>\n<pre><code class=\"language-javascript\">describe('어떤 테스트를 할 것인지 대략적인 설명', function () {\n\n    beforeEach(function () {\n        // 매 it() 마다 실행 할 코드\n    });\n\n    it('테스트 단위 별 설명', function () {\n        // 여기에 Assertion 코드를 둔다.\n    });\n});\n</code></pre>\n<h2>Chai - Library</h2>\n<p>Assertion 라이브러리. 값 비교에 사용한다.</p>\n<p>설치 : <code>npm install chai --save-dev</code></p>\n<pre><code class=\"language-javascript\">describe('어떤 테스트를 할 것인지 대략적인 설명', function () {\n\n    it('테스트 단위 별 설명', function () {\n        // 여기에 Assertion 코드를 둔다.\n        var foo = 'foo';\n        expect(foo).to.equal('foo'); // 통과\n        expect(foo).to.equal('bar'); // 값이 다르므로 통과하지 못함\n    });\n});\n</code></pre>\n<h2>Istanbul - Coverage Tool</h2>\n<p>코드 커버리지. 내 <strong>테스트 코드</strong>가 <strong>모듈의 어디까지 테스트하는지 측정</strong> 하는데 사용한다.</p>\n<p>테스트 시 <code>coverage/</code> 폴더가 생성되어 리포트 페이지(html)를 생성한다. 여기서 실제 모듈이 얼마나 호출 되었는지, 어디가 문맥상 접근하지 않았는지 알 수 있다.</p>\n<p>설치 : <code>npm install istanbul --save-dev</code></p>\n<p>Mocha와 함께 실행 : <code>istanbul cover _mocha</code> (<code>_mocha</code>인 이유는 Mocha의 프로세스 이름을 이용하기 때문)</p>\n<p>별도의 코드는 없다.</p>\n<h1>Proxyquire</h1>\n<p><a href=\"https://github.com/thlorenz/proxyquire\">https://github.com/thlorenz/proxyquire</a></p>\n<h2>proxyquire 모듈 로드 순서 문제</h2>\n<pre><code class=\"language-bash\">src/\n    router/\n        auth.js\n    find-basic-member.js\n    app.js\ntest/\n    test.js\n</code></pre>\n<p><code>app.js</code> -> <code>auth.js</code> -> <code>find-basic-member.js</code> 이와같은 모듈 의존 관계가 있다.</p>\n<p>테스트 대상은 <code>app.js</code>.\nMocking 대상은 <code>auth.js</code>가 사용하는 <code>find-basic-member.js</code></p>\n<p>사용 방법:</p>\n<pre><code class=\"language-javascript\">proxyquire('../src/router/auth', {\n    '../find-basic-member': mockFindBasicMember\n});\nconst app = require('../src/app'); // app uses mock find-basic-member\n</code></pre>\n<p>위 코드가 Mocking 이 되는 이유는\n<code>app.js</code> -> <code>auth.js</code>의 <code>require('../find-basic-member')</code>를 호출하더라도\n<code>proxyrequire</code>에 의해 캐시된 모듈을 이용하기 때문이다.</p>\n<p>nodejs <code>require</code> 또한 캐시된 정보를 사용하기 때문에 여러번 <code>require</code> 해도 실제 파일을 읽는건 한 번 뿐이다.</p>\n<p><em>Forcing proxyquire to reload modules</em> 단락 참고: <a href=\"https://github.com/thlorenz/proxyquire\">https://github.com/thlorenz/proxyquire</a></p>\n<p>다음과 같이 호출 순서를 변경하면 동작하지 않는다:</p>\n<pre><code class=\"language-javascript\">const app = require('../src/app'); // app uses original find-basic-member\nproxyquire('../src/router/auth', {\n    '../find-basic-member': mockFindBasicMember\n});\n</code></pre>\n<p><code>proxyquire</code>가 <code>app.js</code> -> <code>auth.js</code>의 <code>require('../find-basic-member')</code>를 사용한다.</p>\n<h3><code>require('proxyquire').noPreserveCache()</code> 사용하기</h3>\n<p>위의 예제처럼 사용한 경우 <code>proxyquire()</code> 이후에 로드하는 모듈은 모두 Mock Module을 사용한다.</p>\n<p>따라서 명확하게 Mock Module 의존을 주입할 필요가 있다.</p>\n<p><code>noPreserveCache()</code>는 캐시된 모듈을 사용하지 않고 다시 모듈을 로드한다.</p>\n<p><code>proxyquire()</code>의 반환은 Mock Module 이다. 이를 이용해 의존성을 직접 주입한다.</p>\n<pre><code class=\"language-javascript\">const mockAuth = proxyquire('../src/router/auth', {\n    '../find-basic-member': mockFindBasicMember\n});\nconst mockApp = proxyquire('../src/app', {\n    './router/auth': mockAuth\n});\n</code></pre>\n<p>의존의 의존을 모두 명시한다.</p>\n<h1>Proxyquire vs. rewire</h1>\n<p>테스트 할 때 Dependency Injection 하는데 사용하는 도구 2가지 비교.</p>\n<p>rewire: <a href=\"https://github.com/jhnns/rewire\">https://github.com/jhnns/rewire</a></p>\n<p>rewire는 <em>monkey-patching</em> 도구라고 설명하고 있다.</p>\n<p>proxyquire: <a href=\"https://github.com/thlorenz/proxyquire\">https://github.com/thlorenz/proxyquire</a></p>\n<p>proxyquire는 의존 모듈을 덮어 쓴다고 설명하고 있다. <em>overriding dependencies</em></p>\n<h2>어떤 차이가 있을까?</h2>\n<h3>rewire: 테스트 대상 내에 선언한 변수를 가로채어 바꾼다.</h3>\n<pre><code class=\"language-javascript\">// app.js\nvar foo = 1;\nmodule.exports = () => console.log(foo);\n</code></pre>\n<pre><code class=\"language-javascript\">// test.js\nconst rewire = require('rewire');\nconst app = rewire('./app');  // 테스트 대상\n\napp.__set__('foo', 2);\n\napp();  // 2\n</code></pre>\n<h3>proxyquire: 테스트 대상이 <code>require</code>하는 모듈을 바꿔서 보내준다.</h3>\n<pre><code class=\"language-javascript\">// bar.js\nmodule.exports = 1;\n</code></pre>\n<pre><code class=\"language-javascript\">// app.js\nconst bar = require('./bar');\nmodule.exports = () => console.log(foo);\n</code></pre>\n<pre><code class=\"language-javascript\">// test.js\nconst proxyquire = require('proxyquire');\n// 테스트 대상 및 의존 모듈 mocking\nconst app = proxyquire('./app', {\n    './bar': 2\n});\n\napp();  // 2\n</code></pre>\n<h2>rewire 제한사항</h2>\n<p>rewire는 <code>const</code>로 선언된 변수는 변경할 수 없었다. 따라서 의존 모듈을 <code>const</code>에 할당하면 stub 할 수 없다.\n이 문제 때문에 일단 proxyquire를 사용하고 있다.</p>\n<h1>Sinon.JS</h1>\n<p>자바스크립트를 위한 테스트 spies, stubs, mocks.</p>\n<h2><code>new Date()</code> 조작하기</h2>\n<pre><code class=\"language-javascript\">var clock = sinon.useFakeTimers(new Date('1800-01-01 00:00:00'));\nconsole.log(new Date()); // Wed Jan 01 1800 00:00:00 GMT+0900 (KST)\nclock.restore();\nconsole.log(new Date()); // now\n</code></pre>\n<p><code>useFakeTimers()</code>로부터 반환되는 객체의 <code>restore()</code>를 호출하여 조작된 시간을 복구할 수 있다.</p>\n<p>주의할 점은 복구하지 않고 다시 조작하는 경우.</p>\n<pre><code class=\"language-javascript\">var clock1 = sinon.useFakeTimers(new Date('1800-01-01 00:00:00'));\nconsole.log(new Date()); // Wed Jan 01 1800 00:00:00 GMT+0900 (KST)\nvar clock2 = sinon.useFakeTimers(new Date('2000-12-01 00:00:00'));\nconsole.log(new Date()); // Fri Dec 01 2000 00:00:00 GMT+0900 (KST)\nclock2.restore();\nconsole.log(new Date()); // Wed Jan 01 1800 00:00:00 GMT+0900 (KST)\nclock1.restore();\nconsole.log(new Date()); // now\n</code></pre>\n<p>나중에 조작한 시간을 복구해도 이전에 조작한 시간이 남아 있다.</p>\n<p><code>clock1</code>을 바로 복구해도 돌아올 수 있다.</p>\n<pre><code class=\"language-javascript\">var clock1 = sinon.useFakeTimers(new Date('1800-01-01 00:00:00'));\nconsole.log(new Date()); // Wed Jan 01 1800 00:00:00 GMT+0900 (KST)\nvar clock2 = sinon.useFakeTimers(new Date('2000-12-01 00:00:00'));\nconsole.log(new Date()); // Fri Dec 01 2000 00:00:00 GMT+0900 (KST)\nclock1.restore();\nconsole.log(new Date()); // now\n</code></pre>\n<h1>NodeJS data validation</h1>\n<p>웹 서버를 작성할 때, 요청 데이터를 수동으로 검증하는 일은 너무 피곤하다.</p>\n<p>Python Django는 자체적으로 Form 클래스를 제공한다:<br>\n<a href=\"https://developer.mozilla.org/ko/docs/Learn/Server-side/Django/Forms\">https://developer.mozilla.org/ko/docs/Learn/Server-side/Django/Forms</a></p>\n<p>Django Form은 정말 다양한 필드를 지원한다.</p>\n<p>Python Flask는 WTForm 또는 Marshmallow을 사용한다:</p>\n<ul>\n<li><a href=\"https://github.com/wtforms/wtforms\">https://github.com/wtforms/wtforms</a></li>\n<li><a href=\"https://github.com/marshmallow-code/marshmallow\">https://github.com/marshmallow-code/marshmallow</a></li>\n</ul>\n<p>WTForm이 경량하게 사용할 수 있었고, Marshmallow는 사용해보지 않았다.\nMarshmallow는 Django의 Form과 영속성을 결합한 Model Form과 비슷한 기능을 지원하는 거 같다.</p>\n<p>NodeJS는 아직까지 사용해본 적이 없다.\n이때까지 수동으로 처리해왔는데 너무 힘들었다.\n이런거도 해보려다가 말았다:<br>\n<a href=\"https://github.com/Edunga1/grooming-type-checker\">https://github.com/Edunga1/grooming-type-checker</a></p>\n<p>expressjs나 다른 프레임워크는 어떻게 처리하는지 찾아보니 Joi를 사용하는가 보다.\nJoi는 hapijs의 생태계에서 개발되었다.</p>\n<p>hapijs에 종속되지 않아서 어느 곳에서나 사용할 수 있다:</p>\n<blockquote>\n<p>The most powerful schema description language and data validator for JavaScript.</p>\n</blockquote>\n<h1>NodeJS 서버 로컬 요청만 허용하기</h1>\n<p><a href=\"https://stackoverflow.com/questions/14043926/node-js-connect-only-works-on-localhost\">https://stackoverflow.com/questions/14043926/node-js-connect-only-works-on-localhost</a><br>\n여기에서 힌트를 얻었음</p>\n<p><a href=\"https://nodejs.org/api/net.html#net_server_listen_port_host_backlog_callback\">https://nodejs.org/api/net.html#net_server_listen_port_host_backlog_callback</a><br>\n<code>server.listen()</code> 스펙을 보면 포트 번호와 함께 host(ip)를 입력하면 해당 ip만 허용한다.</p>\n<p>기본값은 <code>0.0.0.0</code>이고 '지정되지 않음'을 의미하며 외부 ip의 연결도 허용하지만, <code>127.0.0.1</code>으로 두면 로컬 연결만 허용된다.</p>\n<p>근데, 이렇게 로컬 요청을 구분하는 것은 좋지 않은 것으로 보인다.\nMSA 환경 구축하면 다른 머신의 연결도 있을테니까.\nvirtual host 또는 방화벽으로 막는게 합리적으로 보인다.</p>\n<h1>pm2 deploy 시 주의할 점</h1>\n<p><a href=\"http://pm2.keymetrics.io/docs/usage/deployment/#complete-tutorial\">pm2 deploy tutorial</a>\n처럼 <code>post-deploy</code>를 다음과 같이 저장하는 경우 조심해야 한다.</p>\n<pre><code class=\"language-json\">\"post-deploy\": \"npm install &#x26;&#x26; pm2 startOrRestart ecosystem.json --env production\"\n</code></pre>\n<p><code>pm2 deploy</code> 하면 다음 절차로 일이 발생한다:</p>\n<ol>\n<li>로컬 <code>ecosystem.json</code>과 같은 설정 파일을 읽어들임</li>\n<li>명세한 서버 정보(<code>user</code>, <code>host</code>)로 리모트 서버에 접속</li>\n<li>(리모트 서버에서) git pull</li>\n<li>(리모트 서버에서) npm install</li>\n<li>(리모트 서버에서) pm2 startOrRestart ecosystem.json --env production</li>\n<li>(리모트 서버에서) 위 명령어에 의한 <code>ecosystem.json</code> 설정 파일을 읽어들임</li>\n<li><code>apps</code> 명세에 따른 배포</li>\n</ol>\n<p>그러니까 설정 파일은 로컬에서, 리모트에서 총 2번 읽어들인다.</p>\n<p>그래서 pm2는 현재 브랜치가 트래킹 중인 리모트 브랜치와 달라지면 싱크를 맞추라고 한다: <code>push your changes before deploying</code></p>\n<p>로컬이랑 서버랑 설정 파일이 안맞으면 골치아파진다. 서로 다른 설정 파일을 읽기 때문에 원하는 대로 작업이 이루어지지 않을 수도 있다.\n원인은 로컬에서 실행되는 명령어의 명세인 <code>deploy</code>, 리모트 서버에서 실행되는 명령어의 명세인 <code>apps</code>를 보통 하나의 파일에서 관리하고\n코드베이스에 포함하기 때문인데, 설정 파일을 다른 위치에 두면 로컬과 리모트의 설정 파일의 싱크를 보장할 수 없다.</p>\n<hr>\n<p>pm2로 배포 프로세스를 관리하고 싶어서 설정 파일을 작성하였으나, 데이터베이스 비밀번호를 <code>env</code>에 저장하면 코드베이스에 포함되기 때문에,\n다른 repository로 분리하려 했다.</p>\n<p>그래서 <code>npm run deploy</code>하면 셸 스크립트를 실행하도록 했다:</p>\n<ol>\n<li>pm2 설정 파일을 가지는 저장소<code>git clone git@github.com:user/repo.git .config</code></li>\n<li><code>pm2 deploy .config/ecosystem.json production</code></li>\n</ol>\n<p>리모트 서버에는 <code>config</code> 저장소를 하나 클론 받아놓고 적절한 곳에 두고\n<code>post-deploy</code>를 <code>\"npm install &#x26;&#x26; pm2 startOrRestart /home/node/config/ecosystem.json --env production\"</code>\n설정 파일의 위치를 해당 위치를 가리키도록 했다.</p>\n<p>이러다보니 설정 정보를 업데이트해도 리모트에서 다시 pull 하지 않으면 로컬에서는 최신 설정을, 리모트에서는 이전 설정을 사용하는 문제가 있다.</p>\n<p>따라서 리모트에서도 항상 <code>config</code> 저장소를 clone 후 <code>pm2 startOrRestart</code> 하도록 해야겠다.</p>\n<h1>Jupyter notebook 사용하기</h1>\n<p>[Jupyter Docker Stacks](docker#Jupyter Docker Stacks)</p>\n<h1>Taming architecture complexity in v8</h1>\n<p><a href=\"https://theori.io/research/korean/taming-architecture-complexity-in-v8\">https://theori.io/research/korean/taming-architecture-complexity-in-v8</a></p>\n<p><a href=\"https://v8.dev/blog/csa\">원문</a>을 번역한 글.</p>\n<p>옛날엔 내장 함수(builtin)가 self-hosted, JS로 작성되기도 했다.\n그러다보니 성능 이슈가 있었고, 어셈블리로 다시 작성되었다.</p>\n<p>성능은 향상되었으나, 유지보수를 하는데 어려워졌다.</p>\n<p>그래서 어셈블리어로 변환해주는 중간 계층을 두었다.\n프레임워크처럼 C++ 매크로로 틀에 맞춰 작성하면,\n어셈블리 코드로 변환된다.</p>\n<p>테스트코드 또한 C++로 작성할 수 있다.</p>\n<p>문자열 객체에 길이를 구하는 <code>GetStringLength</code> 함수를 작성하는\n자세한 예시를 보여주니 좋다.</p>\n<p>작성한 C++ 코드의 가독성이 좋아 보인다:</p>\n<pre><code class=\"language-cpp\">TF_BUILTIN(GetStringLength, CodeStubAssembler) {\n    Label not_string(this);\n\n    Node* const maybe_string = Parameter(Descriptor::kInputObject);\n\n    GotoIf(TaggedIsSmi(maybe_string), &#x26;not_string);\n\n    GotoIfNot(IsString(maybe_string), &#x26;not_string);\n\n    Return(LoadStringLength(maybe_string));\n\n    BIND(&#x26;not_string);\n\n    Return(UndefinedConstant());\n}\n</code></pre>\n<p><a href=\"https://medium.com/swlh/1-powerful-way-to-write-robust-code-7c650071fe6b\">견고한 코드를 작성하는 방법</a>\n글이 생각났다. 진입점은 깔끔하게 유지하기.</p>"}},"pageContext":{"id":"2bdb063c-7f09-56d1-9ff8-f046eef2e1b6","__params":{"id":"2bdb063c-7f09-56d1-9ff8-f046eef2e1b6"}}},"staticQueryHashes":[],"slicesMap":{}}
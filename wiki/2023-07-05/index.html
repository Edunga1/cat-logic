<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 5.10.0"/><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><style data-styled="" data-styled-version="5.3.6">.hbDcaS{box-sizing:border-box;padding:4rem 2rem 0 0;background-color:#f5f5f5;}/*!sc*/
.hbDcaS ul{list-style:none;padding-left:1rem;font-size:.8rem;font-weight:bold;}/*!sc*/
.hbDcaS ul ul{font-size:.6rem;font-weight:normal;}/*!sc*/
.hbDcaS ul p{margin:0;}/*!sc*/
.hbDcaS a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g1[id="Toc__Container-sc-1f76i2s-0"]{content:"hbDcaS,"}/*!sc*/
.iPgyli{padding-left:1rem;}/*!sc*/
.iPgyli a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g2[id="WikiContent__Container-sc-q3jb6a-0"]{content:"iPgyli,"}/*!sc*/
.dCzhGQ{display:grid;grid-template-columns:minmax(300px,1fr) minmax(400px,1000px);width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;}/*!sc*/
@media (max-width:1000px){.dCzhGQ{grid-template-columns:1fr;}.dCzhGQ > div:nth-child(1){display:none;}}/*!sc*/
data-styled.g3[id="Wiki__Container-sc-16q9onf-0"]{content:"dCzhGQ,"}/*!sc*/
</style></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="Wiki__Container-sc-16q9onf-0 dCzhGQ"><div><div class="Toc__Container-sc-1f76i2s-0 hbDcaS"><ul>
<li>
<p><a href="#elasticsearch-seminar">Elasticsearch seminar</a></p>
<ul>
<li>
<ul>
<li>
<p><a href="#%EA%B2%80%EC%83%89">검색</a></p>
<ul>
<li><a href="#generative-ai%EC%97%90%EC%84%9C-elasticsearch%EC%9D%98-%ED%8F%AC%EC%A7%80%EC%85%98">Generative AI에서 Elasticsearch의 포지션.</a></li>
</ul>
</li>
<li>
<p><a href="#engine">Engine</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#es-deep-dive">ES Deep Dive</a></p>
<ul>
<li><a href="#%ED%85%8D%EC%8A%A4%ED%8A%B8-%EB%B6%84%EC%84%9D">텍스트 분석</a></li>
<li><a href="#aggregation">Aggregation</a></li>
<li><a href="#%EC%83%89%EC%9D%B8">색인</a></li>
<li><a href="#lucene-segment%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8">Lucene Segment(세그먼트)</a></li>
</ul>
</li>
<li>
<p><a href="#whats-new-in-es-88">What's new in ES 8.8</a></p>
<ul>
<li><a href="#logging">Logging</a></li>
</ul>
</li>
<li>
<p><a href="#">..</a></p>
</li>
</ul>
</li>
</ul></div></div><div class="WikiContent__Container-sc-q3jb6a-0 iPgyli"><h1 id="elasticsearch-seminar" style="position:relative;"><a href="#elasticsearch-seminar" aria-label="elasticsearch seminar permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Elasticsearch seminar</h1>
<p>8.0 변경점
검색 외에도 로깅 등 응용 시스템</p>
<h3 id="검색" style="position:relative;"><a href="#%EA%B2%80%EC%83%89" aria-label="검색 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>검색</h3>
<p>키워드 검색에서 서술형 사용자 질의로 바뀌고 있음</p>
<ul>
<li>e.g. pvc plumbing irrigation systems</li>
<li>e.g. 미시간 주 근처 ~할 수 있는...</li>
<li>e.g. 이커머스 경우, ~동 근처 100m 내 xxx상품</li>
<li>e.g. 인트라넷 문서 검색도 컨텍스트 기반으로.</li>
</ul>
<h4 id="generative-ai에서-elasticsearch의-포지션" style="position:relative;"><a href="#generative-ai%EC%97%90%EC%84%9C-elasticsearch%EC%9D%98-%ED%8F%AC%EC%A7%80%EC%85%98" aria-label="generative ai에서 elasticsearch의 포지션 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generative AI에서 Elasticsearch의 포지션.</h4>
<p>데이터가 증가함에따라 기하급수적으로 늘어나는 비용을 ES가 해결할 수 있다.</p>
<p>Chat GPT는 공개 데이터, 비즈니스에 맞게 개선하려면 private 데이터를 처리할 수 있어야 함.</p>
<p>ES + GAI + Internal DATA
ES는 bridge 역할을 함</p>
<p>e.g.
사용자 질의를 ES에 먼저 던진다. 바로 AI 서비스에 전달하면 비용 증가.
10 document with ChatGPT vs. ES로 정제 후 ChatGPT</p>
<p>e.g.
zalando e-commerce app.
검색, 로깅, ES + ChatGPT 사용하는 중
사용자 검색 질의 시 계정 정보에 대한 컨텍스트가 있어야 정확한 결과 제공 가능
v7 -> v8 migrated, knn 검색 사용</p>
<h3 id="engine" style="position:relative;"><a href="#engine" aria-label="engine permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Engine</h3>
<p>Vector engine</p>
<h2 id="es-deep-dive" style="position:relative;"><a href="#es-deep-dive" aria-label="es deep dive permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ES Deep Dive</h2>
<p>cluster, node, index, shard, segment, document</p>
<p>apache lucene 자바 라이브러리 사용하여 검색 엔진을 구현함
Solr도 lucene 사용중.</p>
<p>eㅐ용량 검색 for clustering</p>
<p>Cluster 가장 큰 단위
여러개의 노드를 관리하는 Clustering. node는 여러개의 shard(쓰레드)로 이룸
무결성, HA를 위한 샤드 recpliation
복제본은 다른 노드에 위치함
노드는 java process
일반적으로 서버 1대당 노드 하나를 설치함. 2개 이상 설치도 가능함</p>
<p>Discovery: 같은 클러스터에 다른 노드를 찾아 바인딩하는 과정</p>
<p>ES는 REST API 제공함. Query 등</p>
<p>document is json format</p>
<p>검색 엔진은 inverted index 구조로 저장
term -> document(id)</p>
<h3 id="텍스트-분석" style="position:relative;"><a href="#%ED%85%8D%EC%8A%A4%ED%8A%B8-%EB%B6%84%EC%84%9D" aria-label="텍스트 분석 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>텍스트 분석</h3>
<ul>
<li>Analyzer라는 도구가 분석함</li>
<li>character filtering -> tokenizing -></li>
<li>일반적으로 whitespace tokenizer가 사용됨</li>
<li>token filtering 대소 변환으로 검색에 유용하게 함, 불용어 제거, 복수형, 동의어 처리(qucik은 fast로도 저장)</li>
</ul>
<p>Analyize API
API로 analzyer api 사용 가능</p>
<p>한글은 사전 기반 분석 필요. 복합어로 이루어짐
은전한닢 등 한국어 분석기 있음
ES Plugin 형태로 Nori라는 한국어 형태소 분석기가 있음</p>
<p>match 검색은 텍스트 검색.
keyword 필드 검색 시 대소문자까지 구분하여 검색</p>
<p>Q.</p>
<ul>
<li>텍스트 분석 도구 제공한다면.. language aware 한 내용은? => 본문에 나옴</li>
<li>플러그인 형태로 제공한다는 것은.. 코드 레벨 처리가 불필요?</li>
</ul>
<h3 id="aggregation" style="position:relative;"><a href="#aggregation" aria-label="aggregation permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Aggregation</h3>
<p>search API에서 검색 count 등</p>
<p>Units:
Bucket: 일반적으로 집단 기반 구분 (namespace?)
Metric: min, max, count
Pipeline: 결과에 대한 추가 처리</p>
<p>위 Unit 별로 Aggregation 가능</p>
<h3 id="색인" style="position:relative;"><a href="#%EC%83%89%EC%9D%B8" aria-label="색인 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>색인</h3>
<p>RR로 도큐먼트들이 각 샤드로 분배됨
Document ID를 알고 있으면 검색 없이 조회 가능</p>
<p>Query Phase</p>
<ul>
<li>쿼리는 가장 먼저 모든 샤드에 전달됨.</li>
<li>각 샤드는 요청만큼 반환함</li>
<li>클라이언트가 10개 요청하면 모든 샤드에서 각각 10개 조회</li>
</ul>
<ol start="2">
<li>Fetch Phase</li>
</ol>
<ul>
<li>노드가 리턴 결과를 랭킹 점수를 기반으로 정렬하여 반환</li>
<li>노드가 모든 결과를 정렬하여 10개만 반환</li>
</ul>
<p>ES는 랭킹 알고리즘으로 TF/IDF
ES5부터 BM25 알고리즘 사용.
(<a href="https://news.hada.io/topic?id=9034">https://news.hada.io/topic?id=9034</a> 여기서 본 거 같으니 정리)</p>
<p>1<del>1000 검색이나 990</del>1000 검색이나 쿼리 처리 규모가 비슷함. 랭킹을 통해 정렬이 필요하므로.</p>
<h3 id="lucene-segment세그먼트" style="position:relative;"><a href="#lucene-segment%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8" aria-label="lucene segment세그먼트 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Lucene Segment(세그먼트)</h3>
<p>inverted index, doc value, 원본 문서 등 저장</p>
<p>문서는 inesrt, delete 만 있음. update 없음</p>
<p>세그먼트 병합을 통해 새로운 세그먼트를 만듦. 비용이 큰 작업이므로 유의.
오래된 세그먼트는 크고, 최근 것은 상대적으로 작음
(이걸 정리하는 용도로 병합하나봄)</p>
<p>세그먼트는 추가, 삭제 과정에서 생성됨
한 번 생성된 세그먼트는 변경되지 않음(immutable)
병합을 통해 2개 세그먼트를 합침
메모리에서 처리 후 flush를 통해 영구 저장됨</p>
<p>세그먼트의 병합은 자동, 수동으로 할 수 있음</p>
<p>ES 도입에 대한 워크벤치 도구.</p>
<h2 id="whats-new-in-es-88" style="position:relative;"><a href="#whats-new-in-es-88" aria-label="whats new in es 88 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's new in ES 8.8</h2>
<p>Search로는 충분하지 않음. vector search의 필요
vector search ~= semenatic search</p>
<p>객체의 비슷함으로 그루핑하여 검색에서 사용함
이미지, 오디오, 도큐먼트를 모두 Vector화하여 저장함
조회 시 Vector로 가져와서 처리함
결과는 도큐먼트를 반환함
ML 모델로 벡터화를 진행함. 대표적인 모델로 BERT를 사용함.</p>
<p>8.0부터 벡터 저장을 제공함</p>
<p>검색을 위해서 벡터는 그래프로 저장됨
전통적인 검색과 벡터 검색을 함께 사용할 수 있다. hybrid scoring이라 함
bm 25는 전통적인 검색, knn는 벡터 검색을 위해 사용함
knn: k-neasrt neighbor</p>
<p>Role 기반으로 민감 데이터를 보호할 수 있음
third-party 모델을 ES에서 설정할 수 있다.
내장 모델이 하나 있음.
bm25 기반으로 벤치마킹하는데, 내장 모델만으로도 12개의 벤치마크에서 좋다고 판단됨</p>
<p>더 나은 결과를 위해서 finetuning이 필요한데, 많은 비용이 발생함
=> finetuning 대신 질의 시 context를 전달하여 정확도를 높이자.
모든 도큐먼트를 GPT에 전달하지 않고, ES를 사용하여 정제된 context를 결과를 받고 GPT에 전달하여 비용을 줄이자.</p>
<h3 id="logging" style="position:relative;"><a href="#logging" aria-label="logging permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Logging</h3>
<p>ES를 사용하면 증가하는 로그 비용을 줄일 수 있다.</p>
<p>Elastic Agent로 각종 integration 사용 가능, k8s 연동이라던가, visualizer 라던가..</p>
<p>Agent에서 로그 검색 기능 제공. AI 기반 검색 가능</p>
<p>(Agent를 이용해서 저장된 로그를 검색에 대한 내용)</p>
<p>data tiering. hot, warm cold, frozen 응답에 따라 결정</p>
<p>cluster cluster search</p>
<ul>
<li>분산된 클러스터를 검색할 수 있음</li>
<li>Google cloud, AWS 나눠서 저장한 경우</li>
</ul>
<h2 id="" style="position:relative;"><a href="#" aria-label=" permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>..</h2>
<p>Coodinator node?
data node와 coordinator node로 구분됨
대부분 느려지는 문제는 coodinator node만 늘려도 해결되었음</p>
<p>(<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html</a> 더 많은 노드 종류가 있는듯)</p></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/wiki/2023-07-05/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-6362d66ed294c92d9487.js\"],\"component---src-pages-404-tsx\":[\"/component---src-pages-404-tsx-75813e24a00d9c44de9f.js\"],\"component---src-pages-index-tsx\":[\"/component---src-pages-index-tsx-031d274001be7ca622ca.js\"],\"component---src-pages-wiki-markdown-remark-fields-slug-tsx\":[\"/component---src-pages-wiki-markdown-remark-fields-slug-tsx-60f280463f16d5c1e8fc.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="6b9cd193cfb2b936c3b2";</script><script src="/cat-logic/webpack-runtime-7332c887ca12e6ecd38c.js" async></script><script src="/cat-logic/framework-3d24f1df4806fe1cdcfc.js" async></script><script src="/cat-logic/app-6362d66ed294c92d9487.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>
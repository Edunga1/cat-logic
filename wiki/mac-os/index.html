<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 5.10.0"/><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><style data-styled="" data-styled-version="5.3.6">.eXfjpt{box-sizing:border-box;background-color:#f5f5f5;padding:1rem 1rem 1rem 0;}/*!sc*/
.eXfjpt ul{list-style:none;padding-left:1rem;margin:0;font-size:.8rem;}/*!sc*/
.eXfjpt ul p{margin:0;}/*!sc*/
.eXfjpt a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g1[id="Toc__Container-sc-1f76i2s-0"]{content:"eXfjpt,"}/*!sc*/
.jjont{overflow:auto;}/*!sc*/
.jjont a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
.jjont pre{font-size:85%;background-color:#f5f5f5;border-radius:.5rem;padding:1rem;overflow:auto;}/*!sc*/
data-styled.g2[id="WikiContent__Container-sc-q3jb6a-0"]{content:"jjont,"}/*!sc*/
.uLsfv{display:grid;grid-template-columns:1fr;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;}/*!sc*/
@media (min-width:700px){.uLsfv{grid-template-columns:minmax(300px,1fr) minmax(400px,1000px);}}/*!sc*/
data-styled.g3[id="Wiki__Container-sc-16q9onf-0"]{content:"uLsfv,"}/*!sc*/
.crmilA{display:none;}/*!sc*/
.crmilA > div:nth-child(2){padding-top:1rem;}/*!sc*/
@media (min-width:700px){.crmilA{display:block;}}/*!sc*/
data-styled.g4[id="Wiki__Side-sc-16q9onf-1"]{content:"crmilA,"}/*!sc*/
.eTgCJx{padding:0 1rem;overflow:auto;}/*!sc*/
@media (min-width:700px){.eTgCJx > div:nth-child(2){display:none;}}/*!sc*/
data-styled.g5[id="Wiki__Main-sc-16q9onf-2"]{content:"eTgCJx,"}/*!sc*/
</style></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="Wiki__Container-sc-16q9onf-0 uLsfv"><div class="Wiki__Side-sc-16q9onf-1 crmilA"><div class="Toc__Container-sc-1f76i2s-0 eXfjpt"><ul>
<li>
<p><a href="#mac-os">Mac OS</a></p>
<ul>
<li>
<p><a href="#homebrew---%EB%A7%A5%EC%9A%A9-%ED%8C%A8%ED%82%A4%EC%A7%80-%EA%B4%80%EB%A6%AC%EC%9E%90">Homebrew - 맥용 패키지 관리자</a></p>
<ul>
<li><a href="#%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC">동작 원리</a></li>
<li><a href="#brewfile">Brewfile</a></li>
</ul>
</li>
<li>
<p><a href="#ngrok%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A7%A5%EC%97%90%EC%84%9C-remote-login-%ED%95%98%EA%B8%B0"><code>ngrok</code>을 이용하여 맥에서 Remote Login 하기</a></p>
<ul>
<li><a href="#1-%EB%A7%A5%EB%B6%81%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-ssh-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%97%88%EC%9A%A9">1. 맥북(서버)에서 SSH 리모트 로그인 허용</a></li>
<li><a href="#2-ngrok%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A7%A5%EB%B6%81%EC%84%9C%EB%B2%84-forwading">2. <code>ngrok</code>을 이용하여 맥북(서버) forwading</a></li>
<li><a href="#3-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%97%90%EC%84%9C-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0">3. 클라이언트에서 접속하기</a></li>
</ul>
</li>
<li>
<p><a href="#secretive---ssh-key%EB%A5%BC-secure-enclave%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94-%EC%95%B1">Secretive - SSH Key를 Secure Enclave에 저장하는 앱</a></p>
<ul>
<li><a href="#multiple-hosts-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">Multiple Hosts 사용하기</a></li>
</ul>
</li>
<li>
<p><a href="#arch-%EB%AA%85%EB%A0%B9%EC%96%B4"><code>arch</code> 명령어</a></p>
</li>
<li>
<p><a href="#displayplacer---%EB%A9%80%ED%8B%B0-%EB%AA%A8%EB%8B%88%ED%84%B0-%EC%84%A4%EC%A0%95-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC">displayplacer - 멀티 모니터 설정 관리 도구</a></p>
</li>
</ul>
</li>
</ul></div><span></span></div><div class="Wiki__Main-sc-16q9onf-2 eTgCJx"><h1>Mac OS</h1><div class="Toc__Container-sc-1f76i2s-0 eXfjpt"><ul>
<li>
<p><a href="#mac-os">Mac OS</a></p>
<ul>
<li>
<p><a href="#homebrew---%EB%A7%A5%EC%9A%A9-%ED%8C%A8%ED%82%A4%EC%A7%80-%EA%B4%80%EB%A6%AC%EC%9E%90">Homebrew - 맥용 패키지 관리자</a></p>
<ul>
<li><a href="#%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC">동작 원리</a></li>
<li><a href="#brewfile">Brewfile</a></li>
</ul>
</li>
<li>
<p><a href="#ngrok%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A7%A5%EC%97%90%EC%84%9C-remote-login-%ED%95%98%EA%B8%B0"><code>ngrok</code>을 이용하여 맥에서 Remote Login 하기</a></p>
<ul>
<li><a href="#1-%EB%A7%A5%EB%B6%81%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-ssh-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%97%88%EC%9A%A9">1. 맥북(서버)에서 SSH 리모트 로그인 허용</a></li>
<li><a href="#2-ngrok%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A7%A5%EB%B6%81%EC%84%9C%EB%B2%84-forwading">2. <code>ngrok</code>을 이용하여 맥북(서버) forwading</a></li>
<li><a href="#3-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%97%90%EC%84%9C-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0">3. 클라이언트에서 접속하기</a></li>
</ul>
</li>
<li>
<p><a href="#secretive---ssh-key%EB%A5%BC-secure-enclave%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94-%EC%95%B1">Secretive - SSH Key를 Secure Enclave에 저장하는 앱</a></p>
<ul>
<li><a href="#multiple-hosts-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">Multiple Hosts 사용하기</a></li>
</ul>
</li>
<li>
<p><a href="#arch-%EB%AA%85%EB%A0%B9%EC%96%B4"><code>arch</code> 명령어</a></p>
</li>
<li>
<p><a href="#displayplacer---%EB%A9%80%ED%8B%B0-%EB%AA%A8%EB%8B%88%ED%84%B0-%EC%84%A4%EC%A0%95-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC">displayplacer - 멀티 모니터 설정 관리 도구</a></p>
</li>
</ul>
</li>
</ul></div><div class="WikiContent__Container-sc-q3jb6a-0 jjont">
<h2 id="homebrew---맥용-패키지-관리자" style="position:relative;"><a href="#homebrew---%EB%A7%A5%EC%9A%A9-%ED%8C%A8%ED%82%A4%EC%A7%80-%EA%B4%80%EB%A6%AC%EC%9E%90" aria-label="homebrew   맥용 패키지 관리자 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Homebrew - 맥용 패키지 관리자</h2>
<p><a href="https://brew.sh/">https://brew.sh/</a></p>
<p>Homebrew로 맥에서 어플리케이션(패키지)을 설치하는 도구이다.</p>
<p>설치할 수 있는 앱은 크게 2가지로 나뉜다. MacOS 전용 앱과 터미널에서 사용할 수 있는 앱이다.
전자는 <code>brew cask install</code>로 설치하고, 후자는 <code>brew install</code>로 설치한다.</p>
<p><code>brew install wget</code>과 같이 사용하며, 이건 <code>wget</code>을 설치하는 명령어이다.
<code>wget</code>를 Hoembrew에서는 <code>formula</code>라고 부른다:</p>
<blockquote>
<p>Homebrew formulae are simple Ruby scripts</p>
</blockquote>
<h3 id="동작-원리" style="position:relative;"><a href="#%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC" aria-label="동작 원리 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>동작 원리</h3>
<p>패키지는 공용 저장소인 <a href="https://github.com/Homebrew/homebrew-core">homebrew-core</a>에서 관리한다.
Ruby 스크립트를 통해서 설치 정보를 선언한다.</p>
<p><code>brew tap &#x3C;repo></code>로 다른 저장소를 추가하여 공용 저장소에 없는 패키지를 설치할 수 있다.</p>
<p>재밌는 점은 공용 Homebrew에는 수많은 패키지가 Git으로 관리되고 있는데,
패키지가 새롭게 추가 되거나 업데이트 되면 Git commit이 발생하는 것이다.
그래서 공용 저장소의 커밋 수는 2023년 6월 기준 37만개가 넘는다.</p>
<p><a href="https://github.com/Homebrew/homebrew-core/pulls">PR</a>을 올리면 Hoembrew 메인테이너 또는 멤버가 리뷰하고
자동화 테스트를 통과하면 봇을 통해 자동 머지된다. 아마 가장 활발한 저장소 중 하나일 것이다.</p>
<h3 id="brewfile" style="position:relative;"><a href="#brewfile" aria-label="brewfile permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Brewfile</h3>
<p><code>Brewfile</code>은 패키지를 관리하는 파일이다.</p>
<p><code>brew bundle dump</code>로 현재 설치된 패키지를 <code>Brewfile</code>에 저장할 수 있다.</p>
<pre><code class="language-bash">$ brew bundle dump
$ cat Brewfile
tap "homebrew/bundle"
tap "homebrew/core"
tap "spring-io/tap"
tap "universal-ctags/universal-ctags"
brew "xz"
brew "zstd"
brew "bzip2"
brew "krb5"
brew "libtirpc"
brew "libnsl"
brew "pcre2"
brew "sqlite"
brew "util-linux"
</code></pre>
<p>단, 자동 생성하면 의존성의 의존성까지 모두 저장되어 불편하다.
나같은 경우는 직접 파일을 생성하여 관리한다: <a href="https://github.com/Edunga1/dotfiles/blob/main/Brewfile">https://github.com/Edunga1/dotfiles/blob/main/Brewfile</a></p>
<h2 id="ngrok을-이용하여-맥에서-remote-login-하기" style="position:relative;"><a href="#ngrok%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A7%A5%EC%97%90%EC%84%9C-remote-login-%ED%95%98%EA%B8%B0" aria-label="ngrok을 이용하여 맥에서 remote login 하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>ngrok</code>을 이용하여 맥에서 Remote Login 하기</h2>
<p>공인 IP없이 맥북에 ssh로 접속하기 위해선 중계자가 필수적이다.
<code>ngrok</code>이 <code>hole punching</code>을 통해서 서버와 클라이언트를 연결하는지는 모르겠지만,
<code>ngrok</code>을 사용하면 쉽게 해결할 수 있다.</p>
<h3 id="1-맥북서버에서-ssh-리모트-로그인-허용" style="position:relative;"><a href="#1-%EB%A7%A5%EB%B6%81%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-ssh-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%97%88%EC%9A%A9" aria-label="1 맥북서버에서 ssh 리모트 로그인 허용 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. 맥북(서버)에서 SSH 리모트 로그인 허용</h3>
<p>먼저, 서버가 되는 맥북은 ssh 연결을 허용해야 한다.
<code>System Preference</code> -> <code>Sharing</code>에서 <code>Remote Login</code>을 체크하면,
초록불이 들어오면서 <code>Remote Login: On</code>으로 상태가 출력된다.
그리고 <code>Allow access for</code>에서 외부 연결에서 사용할 계정을 추가하거나 모두 허용하면 된다.</p>
<h3 id="2-ngrok을-이용하여-맥북서버-forwading" style="position:relative;"><a href="#2-ngrok%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A7%A5%EB%B6%81%EC%84%9C%EB%B2%84-forwading" aria-label="2 ngrok을 이용하여 맥북서버 forwading permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. <code>ngrok</code>을 이용하여 맥북(서버) forwading</h3>
<p>접속하려는 PC든 서버가되는 맥북이든 공유기를 사용하여 Private Network 내에 있을거기 때문에,
공인 IP를 가진 누군가를 통해서 연결해야 한다. <code>ngrok</code>은 그런 일을 도와준다.
무료고 유용하다.</p>
<p>여기에서 어떤 일들이 가능한지 알 수 있다:<br>
<a href="https://ngrok.com/product">https://ngrok.com/product</a></p>
<p>맥북(서버)만 설치하면 된다. Homebrew로 쉽게 설치할 수 있다.</p>
<pre><code class="language-bash">$ brew cask install ngrok
</code></pre>
<p>처음 설치했다면, ngrok 서비스에 로그인이 필요할 수 있다.
일단 진행해보고 인증받으라고 한다면, 로그인 페이지로 들어가서:<br>
<a href="https://dashboard.ngrok.com/user/login">https://dashboard.ngrok.com/user/login</a></p>
<p>로그인하면, 인증 방법이 나온다. <code>ngrok authtoken ...</code>이 나오는 부분을 찾으면 된다.</p>
<p>설치 했으면 ssh port를 ngrok을 통해서 forwarding 되도록 한다.</p>
<pre><code class="language-bash">$ ngrok tcp 22
ngrok by @inconshreveable

Session Status                online
Account                       username (Plan: Free)
Version                       2.3.25
Region                        United States (us)
Web Interface                 http://127.0.0.1:4040
Forwarding                    tcp://0.tcp.ngrok.io:18844 -> localhost:22

Connections                   ttl     opn     rt1     rt5     p50     p90
                              0       0       0.00    0.00    0.00    0.00
</code></pre>
<p>위 화면이 나오면 성공이다.</p>
<p>만약 위에서 ssh remote login 옵션을 허용하지 않았으면 에러가 난다.</p>
<h3 id="3-클라이언트에서-접속하기" style="position:relative;"><a href="#3-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%97%90%EC%84%9C-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0" aria-label="3 클라이언트에서 접속하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. 클라이언트에서 접속하기</h3>
<p><code>ssh</code> 명령어로 접속할 수 있다.</p>
<pre><code class="language-bash">$ ssh username@0.tcp.ngrok.io -p18844
</code></pre>
<p><code>username</code>은 1번에서 sharing에 허용한 사용자 이름을 입력하면 된다.
<code>$ whoami</code> 명령어로도 알 수 있지만.</p>
<p><code>18844</code>는 포트 번호인데, <code>$ ngroc tcp 22</code> 출력되는 화면에서 포트번호를 확인할 수 있다.</p>
<pre><code class="language-bash">...
Forwarding                    tcp://0.tcp.ngrok.io:18844 -> localhost:22
...
</code></pre>
<h2 id="secretive---ssh-key를-secure-enclave에-저장하는-앱" style="position:relative;"><a href="#secretive---ssh-key%EB%A5%BC-secure-enclave%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94-%EC%95%B1" aria-label="secretive   ssh key를 secure enclave에 저장하는 앱 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Secretive - SSH Key를 Secure Enclave에 저장하는 앱</h2>
<p><a href="https://github.com/maxgoedjen/secretive">https://github.com/maxgoedjen/secretive</a></p>
<p>설치:</p>
<pre><code class="language-bash">brew install secretive
</code></pre>
<p><img src="https://github.com/maxgoedjen/secretive/raw/main/.github/readme/app-light.png" alt="main"></p>
<p><a href="https://support.apple.com/ko-kr/guide/security/sec59b0b31ff/web">Secure Enclave</a>는 메인 프로세서와 별도로 격리되어 저장되는 추가적인 보안 계층을 제공한다.</p>
<p>맥북 프로의 경우 T1 칩에 Secure Enclave가 내장되어 있어, 2016년 이후에 출시된 T1, T2 칩을 제공하는 모델에서만 사용할 수 있다.
자세한 동작 원리는 모르지만, 메인 프로세서와 격리된 메모리 영역에 데이터를 저장해서 더 안전하다고 한다.</p>
<p>Secretive는 SSH Key를 Secure Encalve에 저장하는 앱이다.
SSH Key는 앱에서 직접 생성해주는데, 비대칭 암호화 방식의 경우 ECDSA를 사용하고, <strong>개인키는 Secure Enclave에 저장하면서 사용자에게 보여주지 않는다.</strong></p>
<p>개인키를 보여주지 않는 특징과 함께 수정할 수도 없다.</p>
<p>개발하면서 더 이상 키를 확인할 이유는 왠만하면 없기 때문에 하드디스크 <code>~/.ssh</code>에 저장하기 보다는 Secure Enclave에 저장해 둔다면 보안상 더 좋아 보인다.</p>
<p>나같은 경우 GitHub, BitBucket 등에서 사용하는 키를 Secretive로 생성 및 관리하고 있다.</p>
<p>설치하고 <code>~/.ssh/config</code>에 아래 내용을 추가해야 한다.</p>
<pre><code class="language-bash">Host *
  IdentityAgent /Users/johndoe/Library/Containers/com.maxgoedjen.Secretive.SecretAgent/Data/socket.ssh
</code></pre>
<p><code>man ssh_config</code>에 <code>IdentityAgent</code>에 대해 설명되어 있다.
ssh 연결이 발생하면 설정으로 인해 Secretive가 동작하나 보다.</p>
<p>SSH Key에 접근이 필요하면 Touch ID로 인증하거나 알림 배지로 노티를 받거나 설정할 수 있다. 이 기능 때문에 더 안전하다고 느낀다.
인증 방식을 변경하고 싶다면 키를 다시 생성해야 한다. 위에서 언급한 수정할 수 없는 특징 때문이다.
<a href="https://github.com/maxgoedjen/secretive/issues/424#issuecomment-1465047137">관련 이슈</a></p>
<h3 id="multiple-hosts-사용하기" style="position:relative;"><a href="#multiple-hosts-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0" aria-label="multiple hosts 사용하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Multiple Hosts 사용하기</h3>
<p>회사에서 GitHub 개인 계정과 회사 계정을 ssh config로 분리하여 사용하고 있었다:</p>
<pre><code class="language-bash">Host github.com-edunga
  HostName github.com
  User git
  PreferredAuthentications publickey
  IdentityFile ~/.ssh/id_rsa_github_edunga
</code></pre>
<p>개인 프로젝트의 remote url을 <code>git@github.com-edunga</code>로 설정하고 있다.
Secretive 사용하면서 <code>IdentityFile</code>만 제외하면 Secretive와 함께 동작한다.</p>
<pre><code class="language-bash">Host github.com-edunga
  HostName github.com
  User git
  PreferredAuthentications publickey
</code></pre>
<h2 id="arch-명령어" style="position:relative;"><a href="#arch-%EB%AA%85%EB%A0%B9%EC%96%B4" aria-label="arch 명령어 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>arch</code> 명령어</h2>
<p>다른 명령어를 특정 아키텍처 모드로 실행한다.</p>
<p>e.g.</p>
<pre><code class="language-bash">arch -x86_64 &#x3C;COMMAND>
</code></pre>
<p>예를들어 m2 맥북에서 <code>uname -m</code>로 확인하면 아키텍처가 <code>arm64</code> 이지만:</p>
<pre><code class="language-bash">❯ uname -m
arm64
</code></pre>
<p><code>arch -x86_64</code>로 확인하면 <code>x86_64</code> 아키텍처로 나온다:</p>
<pre><code class="language-bash">❯ arch -x86_64 uname -m
x86_64
</code></pre>
<p>대부분 명령어들이 현재 아키텍처에 따라 적절한 바이너리를 선택하는데, arm64 용 바이너리를 못찾아서 에러가 나는 경우가 있다.
x86_64 아키텍처 바이너리와 호환할 수 있는 경우도 있어서 <code>arch</code>로 모드를 변경하여 실행하는 용도로 사용하는 듯 하다.</p>
<p>인자 없이 사용하는 경우 현재 아키텍처를 출력한다:</p>
<pre><code class="language-bash">❯ arch
arm64
</code></pre>
<p><code>-&#x3C;ARCHITECTURE></code> 옵션은 macos에서만 가능하다. linux에서는 옵션 없이 <code>arch</code>만 제공한다.</p>
<h2 id="displayplacer---멀티-모니터-설정-관리-도구" style="position:relative;"><a href="#displayplacer---%EB%A9%80%ED%8B%B0-%EB%AA%A8%EB%8B%88%ED%84%B0-%EC%84%A4%EC%A0%95-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC" aria-label="displayplacer   멀티 모니터 설정 관리 도구 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>displayplacer - 멀티 모니터 설정 관리 도구</h2>
<p><a href="https://github.com/jakehilborn/displayplacer">https://github.com/jakehilborn/displayplacer</a></p>
<p><code>displayplacer</code> 명령어로 모니터 해상도와 배열을 변경한다.</p>
<p>내 경우 아침마다 맥북을 열면 오른쪽과 왼쪽 모니터의 배열이 변경되어 다시 설정에서 정렬해야 문제가 있었다.</p>
<p><code>displayplacer list</code>를 입력하면 조합 가능한 목록을 보여주고, 현재 설정값을 보여준다:</p>
<pre><code class="language-bash">$ displayplacer list
Persistent screen id: 364EA7DB-CF15-4E52-95AC-E3162BC3D207
Contextual screen id: 2
Serial screen id: s828000585
Type: 27 inch external screen
Resolution: 1440x2560
Hertz: 60
Color Depth: 8
Scaling: off
Origin: (0,0) - main display
Rotation: 270
Enabled: true
Resolutions for rotation 270:
  mode 0: res:600x800 hz:75 color_depth:8
  # ... 많아서 생략 ...
  mode 65: res:600x960 hz:60 color_depth:8 scaling:on
  mode 66: res:768x1024 hz:60 color_depth:8
  mode 67: res:720x1280 hz:60 color_depth:8
  mode 68: res:720x1280 hz:60 color_depth:8
  mode 69: res:900x1600 hz:60 color_depth:8
  mode 70: res:1200x1600 hz:60 color_depth:8
  mode 71: res:1080x1920 hz:60 color_depth:8
  mode 72: res:1080x1920 hz:60 color_depth:8
  mode 73: res:1200x1920 hz:60 color_depth:8

Execute the command below to set your screens to the current arrangement. If screen ids are switching, please run `displayplacer --help` for info on using contextual or serial ids instead of persistent ids.

displayplacer "id:364EA7DB-CF15-4E52-95AC-E3162BC3D207 res:1440x2560 hz:60 color_depth:8 enabled:true scaling:off origin:(0,0) degree:270" "id:37D8832A-2D66-02CA-B9F7-8F30A301B230 res:1512x982 hz:120 color_depth:8 enabled:true scaling:on origin:(1440,758) degree:0" "id:5E23DF76-B6A9-4F07-A6A5-F748C75B6E0C res:1440x2560 hz:60 color_depth:8 enabled:true scaling:off origin:(-1440,0) degree:90"
</code></pre>
<p>마지막 줄이 현재 설정된 값을 적용할 수 있는 명령어인데, 복사해두고 아침마다 입력하여 배열을 복구하고 있다.</p></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/wiki/mac-os/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-29ca3cdaaaa8c9a412a9.js\"],\"component---src-pages-404-tsx\":[\"/component---src-pages-404-tsx-75813e24a00d9c44de9f.js\"],\"component---src-pages-index-tsx\":[\"/component---src-pages-index-tsx-e7092de163c5c9dbb3c8.js\"],\"component---src-pages-wiki-markdown-remark-fields-slug-tsx\":[\"/component---src-pages-wiki-markdown-remark-fields-slug-tsx-2e431d905b91cc1690a7.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="9d8fac32e3dc5bae58bb";</script><script src="/cat-logic/webpack-runtime-29d6ddd71fc37ec1f520.js" async></script><script src="/cat-logic/framework-3d24f1df4806fe1cdcfc.js" async></script><script src="/cat-logic/app-29ca3cdaaaa8c9a412a9.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>
<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 5.10.0"/><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><style data-styled="" data-styled-version="5.3.6">.eXfjpt{box-sizing:border-box;background-color:#f5f5f5;padding:1rem 1rem 1rem 0;}/*!sc*/
.eXfjpt ul{list-style:none;padding-left:1rem;margin:0;font-size:.8rem;}/*!sc*/
.eXfjpt ul p{margin:0;}/*!sc*/
.eXfjpt a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g1[id="Toc__Container-sc-1f76i2s-0"]{content:"eXfjpt,"}/*!sc*/
.jjont{overflow:auto;}/*!sc*/
.jjont a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
.jjont pre{font-size:85%;background-color:#f5f5f5;border-radius:.5rem;padding:1rem;overflow:auto;}/*!sc*/
data-styled.g2[id="WikiContent__Container-sc-q3jb6a-0"]{content:"jjont,"}/*!sc*/
.efeuka{padding-top:20rem;}/*!sc*/
data-styled.g3[id="Comments__Container-sc-1ajj4d9-0"]{content:"efeuka,"}/*!sc*/
.uLsfv{display:grid;grid-template-columns:1fr;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;}/*!sc*/
@media (min-width:700px){.uLsfv{grid-template-columns:minmax(300px,1fr) minmax(400px,1000px);}}/*!sc*/
data-styled.g4[id="Wiki__Container-sc-16q9onf-0"]{content:"uLsfv,"}/*!sc*/
.crmilA{display:none;}/*!sc*/
.crmilA > div:nth-child(2){padding-top:1rem;}/*!sc*/
@media (min-width:700px){.crmilA{display:block;}}/*!sc*/
data-styled.g5[id="Wiki__Side-sc-16q9onf-1"]{content:"crmilA,"}/*!sc*/
.eTgCJx{padding:0 1rem;overflow:auto;}/*!sc*/
@media (min-width:700px){.eTgCJx > div:nth-child(2){display:none;}}/*!sc*/
data-styled.g6[id="Wiki__Main-sc-16q9onf-2"]{content:"eTgCJx,"}/*!sc*/
</style></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="Wiki__Container-sc-16q9onf-0 uLsfv"><div class="Wiki__Side-sc-16q9onf-1 crmilA"><div class="Toc__Container-sc-1f76i2s-0 eXfjpt"><ul>
<li>
<p><a href="#mac-os">Mac OS</a></p>
<ul>
<li>
<p><a href="#homebrew---%EB%A7%A5%EC%9A%A9-%ED%8C%A8%ED%82%A4%EC%A7%80-%EA%B4%80%EB%A6%AC%EC%9E%90">Homebrew - 맥용 패키지 관리자</a></p>
<ul>
<li><a href="#%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC">동작 원리</a></li>
<li><a href="#brewfile">Brewfile</a></li>
</ul>
</li>
<li>
<p><a href="#ngrok%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A7%A5%EC%97%90%EC%84%9C-remote-login-%ED%95%98%EA%B8%B0"><code>ngrok</code>을 이용하여 맥에서 Remote Login 하기</a></p>
<ul>
<li><a href="#1-%EB%A7%A5%EB%B6%81%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-ssh-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%97%88%EC%9A%A9">1. 맥북(서버)에서 SSH 리모트 로그인 허용</a></li>
<li><a href="#2-ngrok%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A7%A5%EB%B6%81%EC%84%9C%EB%B2%84-forwading">2. <code>ngrok</code>을 이용하여 맥북(서버) forwading</a></li>
<li><a href="#3-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%97%90%EC%84%9C-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0">3. 클라이언트에서 접속하기</a></li>
</ul>
</li>
<li>
<p><a href="#secretive---ssh-key%EB%A5%BC-secure-enclave%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94-%EC%95%B1">Secretive - SSH Key를 Secure Enclave에 저장하는 앱</a></p>
<ul>
<li><a href="#multiple-hosts-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">Multiple Hosts 사용하기</a></li>
</ul>
</li>
<li>
<p><a href="#arch---%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%B6%9C%EB%A0%A5-%EB%98%90%EB%8A%94-%ED%8A%B9%EC%A0%95-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%A1%9C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%AA%85%EB%A0%B9%EC%96%B4"><code>arch</code> - 아키텍처 출력 또는 특정 아키텍처로 실행하는 명령어</a></p>
</li>
<li>
<p><a href="#open---%ED%8C%8C%EC%9D%BC-%EB%B0%8F-%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC%EB%A5%BC-%EC%97%AC%EB%8A%94-%EB%AA%85%EB%A0%B9%EC%96%B4"><code>open</code> - 파일 및 디렉토리를 여는 명령어</a></p>
</li>
<li>
<p><a href="#displayplacer---%EB%A9%80%ED%8B%B0-%EB%AA%A8%EB%8B%88%ED%84%B0-%EC%84%A4%EC%A0%95-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC">displayplacer - 멀티 모니터 설정 관리 도구</a></p>
</li>
</ul>
</li>
</ul></div><span></span></div><div class="Wiki__Main-sc-16q9onf-2 eTgCJx"><h1>Mac OS</h1><div class="Toc__Container-sc-1f76i2s-0 eXfjpt"><ul>
<li>
<p><a href="#mac-os">Mac OS</a></p>
<ul>
<li>
<p><a href="#homebrew---%EB%A7%A5%EC%9A%A9-%ED%8C%A8%ED%82%A4%EC%A7%80-%EA%B4%80%EB%A6%AC%EC%9E%90">Homebrew - 맥용 패키지 관리자</a></p>
<ul>
<li><a href="#%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC">동작 원리</a></li>
<li><a href="#brewfile">Brewfile</a></li>
</ul>
</li>
<li>
<p><a href="#ngrok%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A7%A5%EC%97%90%EC%84%9C-remote-login-%ED%95%98%EA%B8%B0"><code>ngrok</code>을 이용하여 맥에서 Remote Login 하기</a></p>
<ul>
<li><a href="#1-%EB%A7%A5%EB%B6%81%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-ssh-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%97%88%EC%9A%A9">1. 맥북(서버)에서 SSH 리모트 로그인 허용</a></li>
<li><a href="#2-ngrok%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A7%A5%EB%B6%81%EC%84%9C%EB%B2%84-forwading">2. <code>ngrok</code>을 이용하여 맥북(서버) forwading</a></li>
<li><a href="#3-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%97%90%EC%84%9C-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0">3. 클라이언트에서 접속하기</a></li>
</ul>
</li>
<li>
<p><a href="#secretive---ssh-key%EB%A5%BC-secure-enclave%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94-%EC%95%B1">Secretive - SSH Key를 Secure Enclave에 저장하는 앱</a></p>
<ul>
<li><a href="#multiple-hosts-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">Multiple Hosts 사용하기</a></li>
</ul>
</li>
<li>
<p><a href="#arch---%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%B6%9C%EB%A0%A5-%EB%98%90%EB%8A%94-%ED%8A%B9%EC%A0%95-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%A1%9C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%AA%85%EB%A0%B9%EC%96%B4"><code>arch</code> - 아키텍처 출력 또는 특정 아키텍처로 실행하는 명령어</a></p>
</li>
<li>
<p><a href="#open---%ED%8C%8C%EC%9D%BC-%EB%B0%8F-%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC%EB%A5%BC-%EC%97%AC%EB%8A%94-%EB%AA%85%EB%A0%B9%EC%96%B4"><code>open</code> - 파일 및 디렉토리를 여는 명령어</a></p>
</li>
<li>
<p><a href="#displayplacer---%EB%A9%80%ED%8B%B0-%EB%AA%A8%EB%8B%88%ED%84%B0-%EC%84%A4%EC%A0%95-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC">displayplacer - 멀티 모니터 설정 관리 도구</a></p>
</li>
</ul>
</li>
</ul></div><div class="WikiContent__Container-sc-q3jb6a-0 jjont">
<h2 id="homebrew---맥용-패키지-관리자" style="position:relative;"><a href="#homebrew---%EB%A7%A5%EC%9A%A9-%ED%8C%A8%ED%82%A4%EC%A7%80-%EA%B4%80%EB%A6%AC%EC%9E%90" aria-label="homebrew   맥용 패키지 관리자 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Homebrew - 맥용 패키지 관리자</h2>
<p><a href="https://brew.sh/">https://brew.sh/</a></p>
<p>Homebrew로 맥에서 어플리케이션(패키지)을 설치하는 도구이다.</p>
<p>설치할 수 있는 앱은 크게 2가지로 나뉜다. MacOS 전용 앱과 터미널에서 사용할 수 있는 앱이다.
전자는 <code>brew cask install</code>로 설치하고, 후자는 <code>brew install</code>로 설치한다.</p>
<p><code>brew install wget</code>과 같이 사용하며, 이건 <code>wget</code>을 설치하는 명령어이다.
<code>wget</code>를 Hoembrew에서는 <code>formula</code>라고 부른다:</p>
<blockquote>
<p>Homebrew formulae are simple Ruby scripts</p>
</blockquote>
<p><code>brew info formula</code>로 패키지를 확인할 수 있다.</p>
<pre><code class="language-bash">$ brew info mysql
==> mysql: stable 8.1.0 (bottled)
Open source relational database management system
https://dev.mysql.com/doc/refman/8.0/en/
Conflicts with:
  mariadb (because mysql, mariadb, and percona install the same binaries)
  percona-server (because mysql, mariadb, and percona install the same binaries)
/opt/homebrew/Cellar/mysql/8.1.0 (325 files, 308.4MB) *
  Poured from bottle using the formulae.brew.sh API on 2023-09-20 at 16:33:49
From: https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/m/mysql.rb
License: GPL-2.0-only with Universal-FOSS-exception-1.0
==> Dependencies
Build: bison ✘, cmake ✘, pkg-config ✔
Required: icu4c ✔, libevent ✔, libfido2 ✔, lz4 ✔, openssl@3 ✔, protobuf@21 ✔, zlib ✔, zstd ✔
==> Caveats
We've installed your MySQL database without a root password. To secure it run:
    mysql_secure_installation

MySQL is configured to only allow connections from localhost by default
</code></pre>
<p>패키지 출처 사이트, 패키지 버전, 의존성, 설치 시 주의사항 등이 포함되어 있다.</p>
<h3 id="동작-원리" style="position:relative;"><a href="#%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC" aria-label="동작 원리 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>동작 원리</h3>
<p>패키지는 공용 저장소인 <a href="https://github.com/Homebrew/homebrew-core">homebrew-core</a>에서 관리한다.
Ruby 스크립트로 설치 정보를 명세한다.</p>
<p><code>brew tap &#x3C;repo></code>로 다른 저장소를 추가하여 공용 저장소에 없는 패키지를 설치할 수 있다.</p>
<p>재밌는 점은 공용 Homebrew에는 수많은 패키지가 Git으로 관리되고 있는데,
패키지가 새롭게 추가 되거나 업데이트 되면 Git commit이 발생하는 것이다.
그래서 공용 저장소의 커밋 수는 2023년 6월 기준 37만개가 넘는다.
가장 활발한 저장소 중 하나일 것이다.</p>
<p><a href="https://github.com/Homebrew/homebrew-core/pulls">PR</a>을 올리면 Hoembrew 메인테이너 또는 멤버가 리뷰하고 자동화 테스트를 통과하면 봇이 자동으로 머지한다.</p>
<h3 id="brewfile" style="position:relative;"><a href="#brewfile" aria-label="brewfile permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Brewfile</h3>
<p><code>Brewfile</code>은 패키지를 관리하는 파일이다.</p>
<p><code>brew bundle dump</code>로 현재 설치된 패키지를 <code>Brewfile</code>에 저장할 수 있다.</p>
<pre><code class="language-bash">$ brew bundle dump
$ cat Brewfile
tap "homebrew/bundle"
tap "homebrew/core"
tap "spring-io/tap"
tap "universal-ctags/universal-ctags"
brew "xz"
brew "zstd"
brew "bzip2"
brew "krb5"
brew "libtirpc"
brew "libnsl"
brew "pcre2"
brew "sqlite"
brew "util-linux"
</code></pre>
<p>단, 자동 생성하면 의존성의 의존성까지 모두 저장되어 불편하다.
나같은 경우는 직접 파일을 생성하여 관리한다: <a href="https://github.com/Edunga1/dotfiles/blob/main/Brewfile">https://github.com/Edunga1/dotfiles/blob/main/Brewfile</a></p>
<h2 id="ngrok을-이용하여-맥에서-remote-login-하기" style="position:relative;"><a href="#ngrok%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A7%A5%EC%97%90%EC%84%9C-remote-login-%ED%95%98%EA%B8%B0" aria-label="ngrok을 이용하여 맥에서 remote login 하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>ngrok</code>을 이용하여 맥에서 Remote Login 하기</h2>
<p>공인 IP없이 맥북에 ssh로 접속하기 위해선 중계자가 필수적이다.
<code>ngrok</code>이 <code>hole punching</code>을 통해서 서버와 클라이언트를 연결하는지는 모르겠지만,
<code>ngrok</code>을 사용하면 쉽게 해결할 수 있다.</p>
<h3 id="1-맥북서버에서-ssh-리모트-로그인-허용" style="position:relative;"><a href="#1-%EB%A7%A5%EB%B6%81%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C-ssh-%EB%A6%AC%EB%AA%A8%ED%8A%B8-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%97%88%EC%9A%A9" aria-label="1 맥북서버에서 ssh 리모트 로그인 허용 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. 맥북(서버)에서 SSH 리모트 로그인 허용</h3>
<p>먼저, 서버가 되는 맥북은 ssh 연결을 허용해야 한다.
<code>System Preference</code> -> <code>Sharing</code>에서 <code>Remote Login</code>을 체크하면,
초록불이 들어오면서 <code>Remote Login: On</code>으로 상태가 출력된다.
그리고 <code>Allow access for</code>에서 외부 연결에서 사용할 계정을 추가하거나 모두 허용하면 된다.</p>
<h3 id="2-ngrok을-이용하여-맥북서버-forwading" style="position:relative;"><a href="#2-ngrok%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A7%A5%EB%B6%81%EC%84%9C%EB%B2%84-forwading" aria-label="2 ngrok을 이용하여 맥북서버 forwading permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. <code>ngrok</code>을 이용하여 맥북(서버) forwading</h3>
<p>접속하려는 PC든 서버가되는 맥북이든 공유기를 사용하여 Private Network 내에 있을거기 때문에,
공인 IP를 가진 누군가를 통해서 연결해야 한다. <code>ngrok</code>은 그런 일을 도와준다.
무료고 유용하다.</p>
<p>여기에서 어떤 일들이 가능한지 알 수 있다:<br>
<a href="https://ngrok.com/product">https://ngrok.com/product</a></p>
<p>맥북(서버)만 설치하면 된다. Homebrew로 쉽게 설치할 수 있다.</p>
<pre><code class="language-bash">$ brew cask install ngrok
</code></pre>
<p>처음 설치했다면, ngrok 서비스에 로그인이 필요할 수 있다.
일단 진행해보고 인증받으라고 한다면, 로그인 페이지로 들어가서:<br>
<a href="https://dashboard.ngrok.com/user/login">https://dashboard.ngrok.com/user/login</a></p>
<p>로그인하면, 인증 방법이 나온다. <code>ngrok authtoken ...</code>이 나오는 부분을 찾으면 된다.</p>
<p>설치 했으면 ssh port를 ngrok을 통해서 forwarding 되도록 한다.</p>
<pre><code class="language-bash">$ ngrok tcp 22
ngrok by @inconshreveable

Session Status                online
Account                       username (Plan: Free)
Version                       2.3.25
Region                        United States (us)
Web Interface                 http://127.0.0.1:4040
Forwarding                    tcp://0.tcp.ngrok.io:18844 -> localhost:22

Connections                   ttl     opn     rt1     rt5     p50     p90
                              0       0       0.00    0.00    0.00    0.00
</code></pre>
<p>위 화면이 나오면 성공이다.</p>
<p>만약 위에서 ssh remote login 옵션을 허용하지 않았으면 에러가 난다.</p>
<h3 id="3-클라이언트에서-접속하기" style="position:relative;"><a href="#3-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%97%90%EC%84%9C-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0" aria-label="3 클라이언트에서 접속하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. 클라이언트에서 접속하기</h3>
<p><code>ssh</code> 명령어로 접속할 수 있다.</p>
<pre><code class="language-bash">$ ssh username@0.tcp.ngrok.io -p18844
</code></pre>
<p><code>username</code>은 1번에서 sharing에 허용한 사용자 이름을 입력하면 된다.
<code>$ whoami</code> 명령어로도 알 수 있지만.</p>
<p><code>18844</code>는 포트 번호인데, <code>$ ngroc tcp 22</code> 출력되는 화면에서 포트번호를 확인할 수 있다.</p>
<pre><code class="language-bash">...
Forwarding                    tcp://0.tcp.ngrok.io:18844 -> localhost:22
...
</code></pre>
<h2 id="secretive---ssh-key를-secure-enclave에-저장하는-앱" style="position:relative;"><a href="#secretive---ssh-key%EB%A5%BC-secure-enclave%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94-%EC%95%B1" aria-label="secretive   ssh key를 secure enclave에 저장하는 앱 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Secretive - SSH Key를 Secure Enclave에 저장하는 앱</h2>
<p><a href="https://github.com/maxgoedjen/secretive">https://github.com/maxgoedjen/secretive</a></p>
<p>설치:</p>
<pre><code class="language-bash">brew install secretive
</code></pre>
<p><img src="https://github.com/maxgoedjen/secretive/raw/main/.github/readme/app-light.png" alt="main"></p>
<p><a href="https://support.apple.com/ko-kr/guide/security/sec59b0b31ff/web">Secure Enclave</a>는 메인 프로세서와 별도로 격리되어 저장되는 추가적인 보안 계층을 제공한다.</p>
<p>맥북 프로의 경우 T1 칩에 Secure Enclave가 내장되어 있어, 2016년 이후에 출시된 T1, T2 칩을 제공하는 모델에서만 사용할 수 있다.
자세한 동작 원리는 모르지만, 메인 프로세서와 격리된 메모리 영역에 데이터를 저장해서 더 안전하다고 한다.</p>
<p>Secretive는 SSH Key를 Secure Encalve에 저장하는 앱이다.
SSH Key는 앱에서 직접 생성해주는데, 비대칭 암호화 방식의 경우 ECDSA를 사용하고, <strong>개인키는 Secure Enclave에 저장하면서 사용자에게 보여주지 않는다.</strong></p>
<p>개인키를 보여주지 않는 특징과 함께 수정할 수도 없다.</p>
<p>개발하면서 더 이상 키를 확인할 이유는 왠만하면 없기 때문에 하드디스크 <code>~/.ssh</code>에 저장하기 보다는 Secure Enclave에 저장해 둔다면 보안상 더 좋아 보인다.</p>
<p>나같은 경우 GitHub, BitBucket 등에서 사용하는 키를 Secretive로 생성 및 관리하고 있다.</p>
<p>설치하고 <code>~/.ssh/config</code>에 아래 내용을 추가해야 한다.</p>
<pre><code class="language-bash">Host *
  IdentityAgent /Users/johndoe/Library/Containers/com.maxgoedjen.Secretive.SecretAgent/Data/socket.ssh
</code></pre>
<p><code>man ssh_config</code>에 <code>IdentityAgent</code>에 대해 설명되어 있다.
ssh 연결이 발생하면 설정으로 인해 Secretive가 동작하나 보다.</p>
<p>SSH Key에 접근이 필요하면 Touch ID로 인증하거나 알림 배지로 노티를 받거나 설정할 수 있다. 이 기능 때문에 더 안전하다고 느낀다.
인증 방식을 변경하고 싶다면 키를 다시 생성해야 한다. 위에서 언급한 수정할 수 없는 특징 때문이다.
<a href="https://github.com/maxgoedjen/secretive/issues/424#issuecomment-1465047137">관련 이슈</a></p>
<h3 id="multiple-hosts-사용하기" style="position:relative;"><a href="#multiple-hosts-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0" aria-label="multiple hosts 사용하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Multiple Hosts 사용하기</h3>
<p>회사에서 GitHub 개인 계정과 회사 계정을 ssh config로 분리하여 사용하고 있었다:</p>
<pre><code class="language-bash">Host github.com-edunga
  HostName github.com
  User git
  PreferredAuthentications publickey
  IdentityFile ~/.ssh/id_rsa_github_edunga
</code></pre>
<p>개인 프로젝트의 remote url을 <code>git@github.com-edunga</code>로 설정하고 있다.
Secretive 사용하면서 <code>IdentityFile</code>만 제외하면 Secretive와 함께 동작한다.</p>
<pre><code class="language-bash">Host github.com-edunga
  HostName github.com
  User git
  PreferredAuthentications publickey
</code></pre>
<h2 id="arch---아키텍처-출력-또는-특정-아키텍처로-실행하는-명령어" style="position:relative;"><a href="#arch---%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%B6%9C%EB%A0%A5-%EB%98%90%EB%8A%94-%ED%8A%B9%EC%A0%95-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EB%A1%9C-%EC%8B%A4%ED%96%89%ED%95%98%EB%8A%94-%EB%AA%85%EB%A0%B9%EC%96%B4" aria-label="arch   아키텍처 출력 또는 특정 아키텍처로 실행하는 명령어 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>arch</code> - 아키텍처 출력 또는 특정 아키텍처로 실행하는 명령어</h2>
<p>다른 명령어를 특정 아키텍처 모드로 실행한다.</p>
<p>e.g.</p>
<pre><code class="language-bash">arch -x86_64 &#x3C;COMMAND>
</code></pre>
<p>예를들어 m2 맥북에서 <code>uname -m</code>로 확인하면 아키텍처가 <code>arm64</code> 이지만:</p>
<pre><code class="language-bash">❯ uname -m
arm64
</code></pre>
<p><code>arch -x86_64</code>로 확인하면 <code>x86_64</code> 아키텍처로 나온다:</p>
<pre><code class="language-bash">❯ arch -x86_64 uname -m
x86_64
</code></pre>
<p>대부분 명령어들이 현재 아키텍처에 따라 적절한 바이너리를 선택하는데, arm64 용 바이너리를 못찾아서 에러가 나는 경우가 있다.
x86_64 아키텍처 바이너리와 호환할 수 있는 경우도 있어서 <code>arch</code>로 모드를 변경하여 실행하는 용도로 사용하는 듯 하다.</p>
<p>인자 없이 사용하는 경우 현재 아키텍처를 출력한다:</p>
<pre><code class="language-bash">❯ arch
arm64
</code></pre>
<p><code>-&#x3C;ARCHITECTURE></code> 옵션은 macos에서만 가능하다. linux에서는 옵션 없이 <code>arch</code>만 제공한다.</p>
<h2 id="open---파일-및-디렉토리를-여는-명령어" style="position:relative;"><a href="#open---%ED%8C%8C%EC%9D%BC-%EB%B0%8F-%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC%EB%A5%BC-%EC%97%AC%EB%8A%94-%EB%AA%85%EB%A0%B9%EC%96%B4" aria-label="open   파일 및 디렉토리를 여는 명령어 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>open</code> - 파일 및 디렉토리를 여는 명령어</h2>
<p><code>open .</code>로 현재 폴더를 열거나, <code>open README.md</code>로 특정 파일을 연다.</p>
<p><code>-a "Application Name"</code> 옵션으로 어플리케이션을 열 수 있다.</p>
<p>다음은 구글 크롬을 다른 프로파일로 여는 예시:</p>
<pre><code class="language-bash">open -n -a "Google Chrome" --args --profile-directory="Profile 2"
</code></pre>
<ul>
<li><code>-n</code>: 새로운 인스턴스를 생성한다. 이게 없으면 기존에 열려있는 크롬으로 스위칭만 한다.</li>
<li><code>-a "Google Chrome"</code>: 어플리케이션 이름으로 실행하는 옵션.</li>
<li><code>--args</code>: 이 옵션의 인자는 실행하는 어플리케이션으로 전달된다.</li>
<li><code>--profile-directory</code>: 따라서 이 옵션은 구글 크롬에서 지원하는 옵션.
<ul>
<li>프로파일 위치는 <code>~/Library/Application\ Support/Google/Chrome</code> 여기서 확인할 수 있다.</li>
</ul>
</li>
</ul>
<p>회사 어플리케이션을 테스트하기 위해서 프로파일 2개 이상 만들어두고 사용하는데,
매번 여는 것이 불편해서 다음과 같이 명령어로 만들어 두고 사용하고 있다:</p>
<pre><code>#!/bin/bash

open -n -a "Google Chrome" --args --profile-directory="Profile 1"
open -n -a "Google Chrome" --args --profile-directory="Profile 2"
</code></pre>
<p>명령어는 <code>~/bin</code> 폴더에 저장했다.</p>
<p><code>-a</code> 옵션은 문자열을 받는데, <code>-b</code>는 번들 식별자를 사용한다: <code>open -b com.google.Chrome</code></p>
<p>번들 ID를 알려면: <code>osascript -e 'id of app "Google Chrome"'</code></p>
<h2 id="displayplacer---멀티-모니터-설정-관리-도구" style="position:relative;"><a href="#displayplacer---%EB%A9%80%ED%8B%B0-%EB%AA%A8%EB%8B%88%ED%84%B0-%EC%84%A4%EC%A0%95-%EA%B4%80%EB%A6%AC-%EB%8F%84%EA%B5%AC" aria-label="displayplacer   멀티 모니터 설정 관리 도구 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>displayplacer - 멀티 모니터 설정 관리 도구</h2>
<p><a href="https://github.com/jakehilborn/displayplacer">https://github.com/jakehilborn/displayplacer</a></p>
<p><code>displayplacer</code> 명령어로 모니터 해상도와 배열을 변경한다.</p>
<p>내 경우 아침마다 맥북을 열면 오른쪽과 왼쪽 모니터의 배열이 변경되어 다시 설정에서 정렬해야 문제가 있었다.</p>
<p><code>displayplacer list</code>를 입력하면 조합 가능한 목록을 보여주고, 현재 설정값을 보여준다:</p>
<pre><code class="language-bash">$ displayplacer list
Persistent screen id: 364EA7DB-CF15-4E52-95AC-E3162BC3D207
Contextual screen id: 2
Serial screen id: s828000585
Type: 27 inch external screen
Resolution: 1440x2560
Hertz: 60
Color Depth: 8
Scaling: off
Origin: (0,0) - main display
Rotation: 270
Enabled: true
Resolutions for rotation 270:
  mode 0: res:600x800 hz:75 color_depth:8
  # ... 많아서 생략 ...
  mode 65: res:600x960 hz:60 color_depth:8 scaling:on
  mode 66: res:768x1024 hz:60 color_depth:8
  mode 67: res:720x1280 hz:60 color_depth:8
  mode 68: res:720x1280 hz:60 color_depth:8
  mode 69: res:900x1600 hz:60 color_depth:8
  mode 70: res:1200x1600 hz:60 color_depth:8
  mode 71: res:1080x1920 hz:60 color_depth:8
  mode 72: res:1080x1920 hz:60 color_depth:8
  mode 73: res:1200x1920 hz:60 color_depth:8

Execute the command below to set your screens to the current arrangement. If screen ids are switching, please run `displayplacer --help` for info on using contextual or serial ids instead of persistent ids.

displayplacer "id:364EA7DB-CF15-4E52-95AC-E3162BC3D207 res:1440x2560 hz:60 color_depth:8 enabled:true scaling:off origin:(0,0) degree:270" "id:37D8832A-2D66-02CA-B9F7-8F30A301B230 res:1512x982 hz:120 color_depth:8 enabled:true scaling:on origin:(1440,758) degree:0" "id:5E23DF76-B6A9-4F07-A6A5-F748C75B6E0C res:1440x2560 hz:60 color_depth:8 enabled:true scaling:off origin:(-1440,0) degree:90"
</code></pre>
<p>마지막 줄이 현재 설정된 값을 적용할 수 있는 명령어인데, 복사해두고 아침마다 입력하여 배열을 복구하고 있다.</p></div><div class="Comments__Container-sc-1ajj4d9-0 efeuka"><hr/><div></div></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/wiki/mac-os/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-164a40079806999ba6bd.js\"],\"component---src-pages-404-tsx\":[\"/component---src-pages-404-tsx-75813e24a00d9c44de9f.js\"],\"component---src-pages-index-tsx\":[\"/component---src-pages-index-tsx-22c71a3bf4c35b695119.js\"],\"component---src-pages-wiki-markdown-remark-fields-slug-tsx\":[\"/component---src-pages-wiki-markdown-remark-fields-slug-tsx-212fcad28152c3005b7e.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="a971c1763abdcfa6f669";</script><script src="/cat-logic/webpack-runtime-fd59fd99d0e5f084481d.js" async></script><script src="/cat-logic/framework-3d24f1df4806fe1cdcfc.js" async></script><script src="/cat-logic/app-164a40079806999ba6bd.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>
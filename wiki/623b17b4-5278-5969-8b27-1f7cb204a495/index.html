<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 5.6.0"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div><div><ul>
<li>
<p><a href="#spring-framework">Spring framework</a></p>
</li>
<li>
<p><a href="#webclient-%EC%B2%AB-%EC%9A%94%EC%B2%AD%EC%9D%B4-%EB%8A%90%EB%A6%B0-%EB%AC%B8%EC%A0%9C">WebClient 첫 요청이 느린 문제</a></p>
</li>
<li>
<p><a href="#requestmapping-request-mapping-narrowing"><code>RequestMapping</code> Request mapping narrowing</a></p>
<ul>
<li>
<p><a href="#parameters">parameters</a></p>
<ul>
<li><a href="#value-alias-of-path"><code>value</code> (alias of <code>path</code>)</a></li>
<li><a href="#params"><code>params</code></a></li>
<li><a href="#headers"><code>headers</code></a></li>
</ul>
</li>
</ul>
</li>
</ul></div><div><h1>Spring framework</h1>
<h1>WebClient 첫 요청이 느린 문제</h1>
<p>상황: 서버 시작 직후 다른 서버의 API를 호출하는 내 API가 느려서 클라이언트에서 타임아웃이 자주 발생함.<br>
해결: netty http client의 <code>warmup</code> + 사용자 진입 전 미리 타겟 서버 API 호출</p>
<p><a href="https://projectreactor.io/docs/netty/release/reference/index.html#_eager_initialization_4">https://projectreactor.io/docs/netty/release/reference/index.html#_eager_initialization_4</a></p>
<ol>
<li>warmup으로 event loop pool을 준비시키고</li>
<li>서버 시작 시 임의로 호출하여 모든 사용자 요청은 첫 요청 이후가 되도록 한다.</li>
</ol>
<p>2의 임의 호출은 해당 서버의 health check가 되는 API로 했다.</p>
<p>문서에서 설명하는 첫 요청에서 시간을 소요하는 요소는 다음과 같다:</p>
<ol>
<li>event loop group</li>
<li>host name resolver</li>
<li>내장된 transport 라이브러리들</li>
<li>보안과 관련된 라이브러리들</li>
</ol>
<h1><code>RequestMapping</code> Request mapping narrowing</h1>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestMapping.html">RequestMapping - Spring API</a></p>
<p><code>@RequestMapping</code>는 Controller의 매핑 범위를 줄이는 파라미터를 제공한다.</p>
<p><code>@GetMapping</code> <code>@PostMapping</code> 사용하여 우선 method로 선택 범위를 좁힐 수 있다.</p>
<h2>parameters</h2>
<h3><code>value</code> (alias of <code>path</code>)</h3>
<p>가장 기본적인 인자로, url path를 매핑한다. 기본 값은 빈 문자열이므로 <code>/</code> 와 같다.</p>
<h3><code>params</code></h3>
<p>query-string 매핑.</p>
<ul>
<li><code>myParam=myValue</code> 특정 값인 경우만 매핑한다.</li>
<li><code>myParam!=myValue</code> 위의 반대. 특정 값이 아닌 경우만 매핑한다.</li>
<li><code>!myParam</code> <code>myParam</code> 파라미터 자체가 제공된 경우만 매핑한다.</li>
</ul>
<h3><code>headers</code></h3>
<p>header 매핑.</p>
<p><code>@RequestMapping(value = "/something", headers = "content-type=text/*")</code></p>
<p>wildcard를 사용한 경우 <code>text/plain</code> <code>text/html</code> 모두 매핑한다.</p></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/wiki/623b17b4-5278-5969-8b27-1f7cb204a495/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-81fc23a5f8ac4aaeaf7f.js\"],\"component---src-pages-404-tsx\":[\"/component---src-pages-404-tsx-7bfef5ca48decc695459.js\"],\"component---src-pages-index-tsx\":[\"/component---src-pages-index-tsx-c76c76857518c8e2e8a8.js\"],\"component---src-pages-wiki-markdown-remark-id-tsx\":[\"/component---src-pages-wiki-markdown-remark-id-tsx-b2b1547370b411798096.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="284e4b5de4e5e9ce3311";</script><script src="/webpack-runtime-fd64155da93ce18db3ca.js" async></script><script src="/framework-9b6d338de49a676a1843.js" async></script><script src="/app-81fc23a5f8ac4aaeaf7f.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>
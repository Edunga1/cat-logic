<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="view-transition" content="same-origin"/><meta name="generator" content="Gatsby 5.6.0"/><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><style data-styled="" data-styled-version="5.3.6">.gVurN{display:grid;grid-template-columns:minmax(300px,1fr) minmax(400px,1000px);width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;}/*!sc*/
@media (max-width:1000px){.gVurN{grid-template-columns:1fr;}.gVurN > div:nth-child(1){display:none;}}/*!sc*/
data-styled.g1[id="markdownRemarkfields__slug__Container-sc-cg714z-0"]{content:"gVurN,"}/*!sc*/
.lgmMAy{margin:4rem 2rem 0 0;}/*!sc*/
.lgmMAy ul{list-style:none;}/*!sc*/
.lgmMAy ul p{margin:0;}/*!sc*/
.lgmMAy a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g2[id="markdownRemarkfields__slug__Toc-sc-cg714z-1"]{content:"lgmMAy,"}/*!sc*/
.eSmnmE a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g3[id="markdownRemarkfields__slug__Content-sc-cg714z-2"]{content:"eSmnmE,"}/*!sc*/
</style></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="markdownRemarkfields__slug__Container-sc-cg714z-0 gVurN"><div class="markdownRemarkfields__slug__Toc-sc-cg714z-1 lgmMAy"><ul>
<li>
<p><a href="#docker">Docker</a></p>
</li>
<li>
<p><a href="#osx-%EC%97%90%EC%84%9C-docker-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0">OSX 에서 Docker 환경 구성하기</a></p>
<ul>
<li><a href="#1-homebrew%EB%A1%9C-docker%EC%99%80-docker-machine-%EC%84%A4%EC%B9%98">1. Homebrew로 Docker와 Docker-machine 설치</a></li>
<li><a href="#2-homebrew%EB%A1%9C-virtualbox-%EC%84%A4%EC%B9%98">2. Homebrew로 Virtualbox 설치</a></li>
<li><a href="#3-docker-machine-%EC%84%A4%EC%A0%95">3. docker-machine 설정</a></li>
<li><a href="#4-%EC%83%9D%EC%84%B1%ED%95%9C-docker-machine-%ED%99%9C%EC%84%B1%ED%99%94">4. 생성한 Docker-machine 활성화</a></li>
</ul>
</li>
<li>
<p><a href="#dockerfile%EC%9D%98-volume-%EB%AA%85%EB%A0%B9%EC%96%B4">Dockerfile의 Volume 명령어</a></p>
</li>
<li>
<p><a href="#dockerfile">Dockerfile</a></p>
<ul>
<li><a href="#%EB%AA%85%EB%A0%B9%EC%96%B4">명령어</a></li>
</ul>
</li>
<li>
<p><a href="#%EC%A4%91%EC%A7%80%EB%90%9C-%EB%8F%84%EC%BB%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%97%90%EC%84%9C-%ED%8C%8C%EC%9D%BC-%EB%B3%B5%EC%82%AC%ED%95%98%EA%B8%B0">중지된 도커 컨테이너에서 파일 복사하기</a></p>
</li>
<li>
<p><a href="#jupyter-notebook--nodejs-%EB%8F%84%EC%BB%A4%EB%9D%BC%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%A1%9D">Jupyter Notebook + NodeJS 도커라이징 기록</a></p>
<ul>
<li><a href="#jupyter-docker-stacks">Jupyter Docker Stacks</a></li>
<li><a href="#end">End</a></li>
</ul>
</li>
<li>
<p><a href="#hostdockerinternal%EB%A1%9C-%ED%98%B8%EC%8A%A4%ED%8A%B8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0"><code>host.docker.internal</code>로 호스트 서비스 접근하기</a></p>
<ul>
<li><a href="#%EB%8C%80%EC%B2%B4%EB%8A%94">대체는?</a></li>
</ul>
</li>
<li>
<p><a href="#references">References</a></p>
</li>
</ul></div><div class="markdownRemarkfields__slug__Content-sc-cg714z-2 eSmnmE"><h1 id="docker" style="position:relative;"><a href="#docker" aria-label="docker permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Docker</h1>
<h1 id="osx-에서-docker-환경-구성하기" style="position:relative;"><a href="#osx-%EC%97%90%EC%84%9C-docker-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0" aria-label="osx 에서 docker 환경 구성하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OSX 에서 Docker 환경 구성하기</h1>
<p><strong>docker desktop 또는 rancher desktop이 나와서 이 방법은 더 이상 사용하지 않는다.</strong></p>
<pre><code class="language-bash">brew install --cask docker
</code></pre>
<p>docker desktop은 기업인 경우 규모에 따라 유료 버전을 사용해야 한다. 라이센스에 주의하자.</p>
<pre><code class="language-bash">brew install --cask rancher
</code></pre>
<p>rancher desktop은 무료 사용 가능하다.</p>
<h2 id="1-homebrew로-docker와-docker-machine-설치" style="position:relative;"><a href="#1-homebrew%EB%A1%9C-docker%EC%99%80-docker-machine-%EC%84%A4%EC%B9%98" aria-label="1 homebrew로 docker와 docker machine 설치 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. Homebrew로 Docker와 Docker-machine 설치</h2>
<pre><code class="language-bash">$ brew install docker docker-machine
</code></pre>
<p>docker-machine: 맥을 마치 Host OS 처럼 사용 할 수 있도록 해주는 프로그램</p>
<h2 id="2-homebrew로-virtualbox-설치" style="position:relative;"><a href="#2-homebrew%EB%A1%9C-virtualbox-%EC%84%A4%EC%B9%98" aria-label="2 homebrew로 virtualbox 설치 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. Homebrew로 Virtualbox 설치</h2>
<pre><code class="language-bash">$ brew cask install virtualbox
</code></pre>
<p>Virtualbox: 가상화 프로그램. 맥에서 docker-machine(Host OS, Linux)을 운영하기 위해서 사용</p>
<h2 id="3-docker-machine-설정" style="position:relative;"><a href="#3-docker-machine-%EC%84%A4%EC%A0%95" aria-label="3 docker machine 설정 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. docker-machine 설정</h2>
<pre><code class="language-bash">$ docker-machine create -d virtualbox default
</code></pre>
<p>virtualbox driver를 이용하여 <code>default</code> 이름의 Docker-machine을 생성</p>
<p>virtualbox에 Docker-machine이 올라간다.</p>
<h2 id="4-생성한-docker-machine-활성화" style="position:relative;"><a href="#4-%EC%83%9D%EC%84%B1%ED%95%9C-docker-machine-%ED%99%9C%EC%84%B1%ED%99%94" aria-label="4 생성한 docker machine 활성화 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4. 생성한 Docker-machine 활성화</h2>
<p>Docker-machine을 생성했지만, 아직 <code>docker</code> 명령어를 이용할 수 없다.</p>
<p>Docker-machine을 여러개 관리할 수 있다. 따라서 사용하고자 하는 Docker-machine을 활성화해야 한다.</p>
<pre><code class="language-bash">$ docker-machine ls
NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS
default   -        virtualbox   Running   tcp://192.168.99.100:2376           v17.03.0-ce

$ docker-machine env default
export DOCKER_TLS_VERIFY="1"
export DOCKER_HOST="tcp://192.168.99.100:2376"
export DOCKER_CERT_PATH="/Users/parkdu/.docker/machine/machines/default"
export DOCKER_MACHINE_NAME="default"
# Run this command to configure your shell:
# eval $(docker-machine env default)
</code></pre>
<p>위 명령어로 <code>default</code> Docker-machine의 환경 정보를 알 수 있다.</p>
<p>그리고 마지막 <code>eval</code> 명령어로 활성화 할 수 있다.</p>
<pre><code class="language-bash">$ eval $(docker-machine env default)
$ docker-machine ls
NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS
default   *        virtualbox   Running   tcp://192.168.99.100:2376           v17.03.0-ce
</code></pre>
<p>ACTIVE 속성이 <code>*</code>로 변경되었다.</p>
<p>이제 맥에서 <code>docker</code> 명령어를 사용할 수 있다!</p>
<h1 id="dockerfile의-volume-명령어" style="position:relative;"><a href="#dockerfile%EC%9D%98-volume-%EB%AA%85%EB%A0%B9%EC%96%B4" aria-label="dockerfile의 volume 명령어 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dockerfile의 Volume 명령어</h1>
<p>다음과 같이 컨테이너를 띄우면 <code>docker run -ti --rm -v $(pwd):/myvol --name foo ubuntu</code>
현재 디렉토리를 컨테이너와 공유하여 사용할 수 있다.</p>
<p>그런데 <strong>Dockerfile</strong> 내에서 <code>VOLUME</code> 키워드를 사용하면 호스트를 지정해 줄 수 없다.</p>
<p>그리고 호스트의 디렉토리를 생략하여 <code>-v</code> 옵션을 줄 수 있다: <code>docker run -ti --rm -v /myvol --name foo ubuntu</code></p>
<p>이는 컨테이너의 경로만 지정한 것이 된다.</p>
<p><code>docker inspect</code>로 보면 호스트의 디렉토리(<code>source</code>)는 이상한 곳에 연결되어 있다:</p>
<pre><code class="language-json">"Mounts": [
    {
        "Type": "volume",
        "Name": "922a144309641e2cb18e84498b6b3b5f7f55eacd8073b37062b1dc50cc568814",
        "Source": "/var/lib/docker/volumes/922a144309641e2cb18e84498b6b3b5f7f55eacd8073b37062b1dc50cc568814/_data",
        "Destination": "/myvol",
        "Driver": "local",
        "Mode": "",
        "RW": true,
        "Propagation": ""
    }
],
</code></pre>
<p>이건 어디다 어떻게 쓰는가?</p>
<p><strong>컨테이너간 데이터 공유</strong> 위해서 사용한다.</p>
<ol>
<li><code>foo</code> 컨테이너를 띄운다:<br></li>
</ol>
<p><code>docker run -ti --rm -v /myvol --name foo ubuntu</code></p>
<ol start="2">
<li>그리고 <code>foo</code> 컨테이너와 데이터를 함께 사용할 <code>bar</code>를 띄운다:<br></li>
</ol>
<p><code>docker run -ti --rm --volumes-from foo --name bar ubuntu</code></p>
<ol start="3">
<li><code>foo</code>와 <code>bar</code> 내에서 볼륨 연결된 디렉토리가 비어있음을 확인한다:<br></li>
</ol>
<p><code>ls myvol</code></p>
<ol start="4">
<li><code>foo</code>에서 <code>text</code> 라는 파일을 생성해본다:<br></li>
</ol>
<p><code>touch myvol/text</code></p>
<ol start="5">
<li><code>bar</code>에도 <code>myvol/text</code> 라는 파일이 생성되었음을 확인한다:<br></li>
</ol>
<p><code>ls myvol</code></p>
<p>즉, 호스트 디렉토리 연결 없이 볼륨을 사용한다면 <code>--volumes-from</code> 옵션을 사용하는 컨테이너가 있음을 의미한다.</p>
<h1 id="dockerfile" style="position:relative;"><a href="#dockerfile" aria-label="dockerfile permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dockerfile</h1>
<p>도커 이미지를 빌드하기 위한 명령어들을 모아놓은 파일.</p>
<p>스크립트로 이루어져 있기 때문에 이미지를 관리하는 것보다 훨씬 비용이 적게 든다는 장점이 있다.</p>
<p>각 명령어 마다 이전 이미지로부터 새로운 이미지를 생성한다.(Layer)</p>
<h2 id="명령어" style="position:relative;"><a href="#%EB%AA%85%EB%A0%B9%EC%96%B4" aria-label="명령어 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>명령어</h2>
<p><strong>CMD</strong></p>
<p>컨테이너 시작 시 실행 할 명령어</p>
<ul>
<li><code>CMD &#x3C;command></code></li>
<li><code>CMD ["executable","param1","param2"]</code></li>
</ul>
<p><strong>RUN</strong></p>
<p>빌드 시 실행할 명령어, 일반적으로 이미지의 환경을 구성하는데 사용한다.</p>
<ul>
<li><code>RUN &#x3C;command></code></li>
<li><code>RUN ["executable", "param1", "param2"]</code></li>
<li><code>RUN apt-get install -y nodejs</code></li>
</ul>
<p><strong>ENV</strong></p>
<p>환경 변수 설정. RUN, CMD 명령어 모두에서 영향을 받는다.</p>
<ul>
<li><code>ENV &#x3C;key> &#x3C;value></code></li>
<li><code>ENV &#x3C;key>=&#x3C;value></code></li>
</ul>
<p><strong>WORKDIR</strong></p>
<p>작업 디렉토리 설정. RUN, CMD 명령어의 실행 위치를 설정한다.</p>
<ul>
<li><code>WORKDIR &#x3C;path></code></li>
</ul>
<p><a href="https://docs.docker.com/engine/reference/builder/#add">ADD</a> or <a href="https://docs.docker.com/engine/reference/builder/#copy">COPY</a></p>
<p>호스트의 파일을 이미지에 추가.</p>
<ul>
<li><code>ADD &#x3C;src> &#x3C;dest></code></li>
<li><code>ADD &#x3C;git ref> &#x3C;dir></code> git 저장소에서 파일을 가져온다.</li>
</ul>
<p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy">ADD와 COPY 차이점</a>:</p>
<blockquote>
<p>Although ADD and COPY are functionally similar, generally speaking, COPY is preferred. That’s because it’s more transparent than ADD. COPY only supports the basic copying of local files into the container, while ADD has some features (like local-only tar extraction and remote URL support) that are not immediately obvious. Consequently, the best use for ADD is local tar file auto-extraction into the image, as in ADD rootfs.tar.xz /.</p>
</blockquote>
<p>Best Practice 문서에서 설명하기를, 기능 자체는 비슷하나 일반적(파일 복사)으로 <code>COPY</code>를 선호한다. 더 명확하기 때문이다.
<code>ADD</code>에는 추가 기능이 있는데, tar 파일 압축 해제나 원격 URL 지원, git 저장소를 추가할 수 있다.</p>
<p><a href="https://docs.docker.com/engine/reference/builder/#expose">EXPOSE</a></p>
<blockquote>
<p>The EXPOSE instruction does not actually publish the port. It functions as a type of documentation between the person who builds the image and the person who runs the container, about which ports are intended to be published.</p>
</blockquote>
<p><code>EXPOSE</code>는 포트를 실제로 열지 않는다. 이미지 빌드하는 사람과 컨테이너를 실행하는 사람 사이의 문서 역할을 한다.
<code>-p</code> 옵션으로 포트를 열거나, docker-compose의 <code>ports</code>를 사용하여 포트를 열자.</p>
<p><code>EXPOSE</code>를 주면, 컨테이너를 생성하여 <code>docker ps</code>로 컨테이너를 확인했을 때 <code>PORTS</code> 열에 포트 정보가 표시된다.</p>
<pre><code class="language-bash">CONTAINER ID        IMAGE                          COMMAND                  CREATED             STATUS              PORTS                                                            NAMES
9f8fa8cbf88c        grokzen/redis-cluster:latest   "/docker-entrypoint.…"   27 minutes ago      Up 27 minutes       5000-5002/tcp, 6379/tcp, 7001-7007/tcp, 0.0.0.0:6379->7000/tcp   redis-cluster
</code></pre>
<p>여기서 <code>5000-5002/tcp, 6379/tcp, 7001-7007/tcp</code>는 <code>EXPOSE</code>로 명세했지만 호스트에는 노출되지 않았다.
즉, <code>EXPOSE</code>는 포트 대기중을 의미한다.</p>
<h1 id="중지된-도커-컨테이너에서-파일-복사하기" style="position:relative;"><a href="#%EC%A4%91%EC%A7%80%EB%90%9C-%EB%8F%84%EC%BB%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%97%90%EC%84%9C-%ED%8C%8C%EC%9D%BC-%EB%B3%B5%EC%82%AC%ED%95%98%EA%B8%B0" aria-label="중지된 도커 컨테이너에서 파일 복사하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>중지된 도커 컨테이너에서 파일 복사하기</h1>
<p><code>docker ps -a</code>로 중지된 컨테이너가 있다면 그 컨테이너로부터 파일을 호스트로 복사해올 수 있다</p>
<p><code>docker cp 컨테이너:경로 호스트경로</code>로 복사한다.<br>
컨테이너와 호스트를 반대로 입력하여 중지된 컨테이너에 파일을 주입할 수도 있을 거 같다.</p>
<p>반면 <code>docker exec</code>는 중지된 컨테이너에 접속할 수 없다.</p>
<hr>
<p>ionic으로 빌드를 하고, jarsginer로 서명까지하여 릴리즈 apk를 만드는 도커파일을 작성했다.<br>
그리고 apk를 생성하면 컨테이너는 종료된다.<br>
젠킨스에 등록하여 master 브랜치가 업데이트 될 때마다 apk를 뽑아서, GCP bucket에 업로드하도록 작성했다.<br></p>
<p>처음엔 볼륨을 연결하여 호스트에 생성되도록 했으나 <code>mkdir /root/workspace: read-only file system.</code>에러가 뜬다.<br>
젠킨스 slave의 문제인지. 어차피 볼륨으로 뿜어내는 방식이 내키지 않아서 다른 방식을 찾았다.<br>
무한 루프를 돌도록해서 컨테이너가 죽지 않도록하여 복사해올까 하다가, 중지된 컨테이너에서 가져올 수 있었다.</p>
<p>중지된 컨테이너가 다른 컨테이너에 볼륨을 공유하는 data-only 패턴과 비슷한 방식인듯?</p>
<h1 id="jupyter-notebook--nodejs-도커라이징-기록" style="position:relative;"><a href="#jupyter-notebook--nodejs-%EB%8F%84%EC%BB%A4%EB%9D%BC%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%A1%9D" aria-label="jupyter notebook  nodejs 도커라이징 기록 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Jupyter Notebook + NodeJS 도커라이징 기록</h1>
<p>Jupyter Notebook이 너무 유용한 거 같아서 NodeJS도 쓰고 싶어졌다.</p>
<ol>
<li>
<p>찾아보니 기존 Jupyter 환경에 npm <code>ijavascript</code>라는 cli를 설치하면 기존 Python에 NodeJS 노트까지 추가할 수 있었다.</p>
</li>
<li>
<p>하지만 python, nodejs 관련 모듈을 설치하면 너무 복잡해져서 나중에 다시 환경 구성하기 힘들 거 같아서</p>
</li>
</ol>
<p>도커 쪽으로 눈길을 돌렸다.</p>
<ol>
<li>찾아보니 Python, Go, NodeJs 모두 가능한 도커 이미지를 찾았다:</li>
</ol>
<p><a href="https://github.com/dting/docker-jupyter-go-js">https://github.com/dting/docker-jupyter-go-js</a><br>
오피셜(docker hub 말고) Jupyter Notebook 이미지를 base로 작성된
Go 언어 용 Jupyter 이미지를 base로 작성된 도커 이미지였다. (음)</p>
<ol>
<li>문제는 오래된 이미지다 보니 node 버전도 낮고, pip 버전도 낮아서</li>
</ol>
<p><a href="https://facebook.github.io/prophet/docs/quick_start.html">fbprophet</a>
모듈이 설치가 안되었다. Dockerfile을 복사해서 다시 이미지를 빌드하려 했으나
지금은 사라진 <code>jupyter/notebook</code>이라는 이미지를 base로 하고 있어서 다시 작성하기 어려웠다.</p>
<ol>
<li>좀 더 찾아보다가 <a href="https://hub.docker.com/r/mfellner/javascript-notebook">https://hub.docker.com/r/mfellner/javascript-notebook</a> 이미지를 찾았다.</li>
</ol>
<p>오래 되었지만, 지금도 관리되고 있는 <code>jupyter/minimal-notebook</code>를
base로 하고 있어서, 참고하여 Dockerfile을 다시 작성하기로 했다.</p>
<ol>
<li><code>mfellner/javascript-notebook</code> Dockerfile을 수정해서 nodejs 버전을 올리고</li>
</ol>
<p><code>6.0.0</code> -> <code>10.15.3</code> 빌드했다.</p>
<ol>
<li>실행은 잘 되나, 최초 연결 시 비밀번호/토큰을 입력해야 했다.</li>
</ol>
<p>어차피 로컬에서만 사용할거라 불필요하다고 판단돼서, jupyter notebook 옵션인
<code>--NotebookApp.token=''</code>을 시작 스크립트인 <code>start-notebook.sh</code>에 주었으나,
<code>mfellner/javascript-notebook</code>에서 원본 스크립트를 <code>ijavascript</code> 실행 명령어로 덮어 씌우고 있어서,
적용되지 않고 계속 토큰을 입력해야 했다.</p>
<ol>
<li>
<p>그래서 덮어 씌우는 부분을 Dockerfile에서 제거하고 빌드했으나, 언어 목록에서 nodejs가 제외되었다. 찾아보니</p>
<pre><code class="language-json">{
  "argv": [
    "node",
    "/usr/local/lib/node_modules/ijavascript/lib/kernel.js",
    "{connection_file}",
    "--protocol=5.0"
  ],
  "display_name": "Javascript (Node.js)",
  "language": "javascript"
}
</code></pre>
<p>커널 정보를 이런 포맷으로, Jupyter Notebook의 특정 위치에 두어야 언어 목록에서 출력되는 것이었다.
<code>ijavascript</code>는 <code>ijsinstall</code>이라는 명령어로 환경 구성을 할 때 <code>json</code> 파일을 추가도 해 주고 있었다:
<a href="https://github.com/n-riesco/ijavascript/blob/d459956f76a22f9ec89937e02645ee7555f92d2b/bin/rc.js#L525">https://github.com/n-riesco/ijavascript/blob/d459956f76a22f9ec89937e02645ee7555f92d2b/bin/rc.js#L525</a></p>
</li>
<li>
<p>그래서 간단하게 <code>RUN ijsinstall</code> 해 줘서, 원본 <code>start-notebook.sh</code>는 수정하지 않아도 잘 실행되도록 했다.</p>
</li>
</ol>
<h2 id="jupyter-docker-stacks" style="position:relative;"><a href="#jupyter-docker-stacks" aria-label="jupyter docker stacks permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Jupyter Docker Stacks</h2>
<p>Jupyter Notebook의 도커 버전은 상당히 많은 시리즈로 되어 있다.
도커 허브엔 설명이 적고 GitHub: <a href="https://github.com/jupyter/docker-stacks">https://github.com/jupyter/docker-stacks</a> 에 메뉴얼이 잘 되어 있다.</p>
<p>Dockerfile 관계 트리를 보면 멋있다:<br>
<a href="http://interactive.blockdiag.com/?compression=deflate&#x26;src=eJyFzTEPgjAQhuHdX9Gws5sQjGzujsaYKxzmQrlr2msMGv-71K0srO_3XGud9NNA8DSfgzESCFlBSdi0xkvQAKTNugw4QnL6GIU10hvX-Zh7Z24OLLq2SjaxpvP10lX35vCf6pOxELFmUbQiUz4oQhYzMc3gCrRt2cWe_FKosmSjyFHC6OS1AwdQWCtyj7sfh523_BI9hKlQ25YdOFdv5fcH0kiEMA">http://interactive.blockdiag.com/?compression=deflate&#x26;src=eJyFzTEPgjAQhuHdX9Gws5sQjGzujsaYKxzmQrlr2msMGv-71K0srO_3XGud9NNA8DSfgzESCFlBSdi0xkvQAKTNugw4QnL6GIU10hvX-Zh7Z24OLLq2SjaxpvP10lX35vCf6pOxELFmUbQiUz4oQhYzMc3gCrRt2cWe_FKosmSjyFHC6OS1AwdQWCtyj7sfh523_BI9hKlQ25YdOFdv5fcH0kiEMA</a></p>
<p>커스터마이징하려면 <code>jupyter/notebook-minimal</code>을 기반으로 하면 될 거 같다.</p>
<p><a href="https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html#jupyter-base-notebook">https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html#jupyter-base-notebook</a>
여기에 데이터과학, 머신러닝 등 각 분야에 자주 사용하는 모듈을 미리 설치한 이미지들 정보가 나와있다.</p>
<h2 id="end" style="position:relative;"><a href="#end" aria-label="end permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>End</h2>
<p>Jupyter Notebook NodeJS 도커라이징한 것은 여기에 올렸다:<br>
<a href="https://github.com/Edunga1/jupyter-notebook-nodejs">https://github.com/Edunga1/jupyter-notebook-nodejs</a></p>
<p>Dockerfile 작성하면서 <code>MAINTAINER</code>가 deprecated, <code>LABEL</code>을 사용해야 하는 것을 알았다: <a href="https://stackoverflow.com/questions/38899977/how-do-i-declare-multiple-maintainers-in-my-dockerfile">https://stackoverflow.com/questions/38899977/how-do-i-declare-multiple-maintainers-in-my-dockerfile</a></p>
<h1 id="hostdockerinternal로-호스트-서비스-접근하기" style="position:relative;"><a href="#hostdockerinternal%EB%A1%9C-%ED%98%B8%EC%8A%A4%ED%8A%B8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0" aria-label="hostdockerinternal로 호스트 서비스 접근하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>host.docker.internal</code>로 호스트 서비스 접근하기</h1>
<p><code>host.docker.internal</code>은 호스트의 ip를 가르키는 DNS name이다.
<a href="https://docs.docker.com/desktop/networking/#i-want-to-connect-from-a-container-to-a-service-on-the-host">container에서 호스트의 서비스에 접근</a>이 필요할 때 사용한다.</p>
<blockquote>
<p>This is for development purpose and does not work in a production environment outside of Docker Desktop.</p>
</blockquote>
<p>주의할 점은 <strong>docker-desktop</strong> 에서 제공하는 것이다. rancher-desktop 등 다른 도구로 docker 구성했다면 사용할 수 없다.</p>
<h2 id="대체는" style="position:relative;"><a href="#%EB%8C%80%EC%B2%B4%EB%8A%94" aria-label="대체는 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>대체는?</h2>
<p><code>docker</code> 명령어:</p>
<pre><code class="language-bash">docker run --add-host=host.docker.internal:host-gateway
</code></pre>
<p><code>docker-compose.yml</code>:</p>
<pre><code class="language-yaml">my_app:
  extra_hosts:
    - "host.docker.internal:host-gateway"
</code></pre>
<p>반드시 <code>host.docker.internal</code> 필요는 없다. 편한 것으로 수정하면 된다.</p>
<p><code>host-gateway</code>의 정보는 잘 모르겠다. 가상화 도구 중 <code>dockerd</code>만 제공하는 것으로 보인다.</p>
<p><code>dockerd</code> cli 문서만 있고, 간단하게 설명되어 있다:</p>
<p><a href="https://docs.docker.com/engine/reference/commandline/dockerd/">https://docs.docker.com/engine/reference/commandline/dockerd/</a></p>
<blockquote>
<p>--host-gateway-ip ip
IP address that the special 'host-gateway' string in --add-host resolves to.
Defaults to the IP address of the default bridge</p>
</blockquote>
<h1 id="references" style="position:relative;"><a href="#references" aria-label="references permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>References</h1>
<p>NodeJS 어플리케이션의 Dockerizing<br>
<a href="https://nodejs.org/en/docs/guides/nodejs-docker-webapp/">https://nodejs.org/en/docs/guides/nodejs-docker-webapp/</a></p></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/wiki/docker/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-c3df7cc128b1fd8badc3.js\"],\"component---src-pages-404-tsx\":[\"/component---src-pages-404-tsx-7bfef5ca48decc695459.js\"],\"component---src-pages-index-tsx\":[\"/component---src-pages-index-tsx-a6d255ad0e2dec90f2a0.js\"],\"component---src-pages-wiki-markdown-remark-fields-slug-tsx\":[\"/component---src-pages-wiki-markdown-remark-fields-slug-tsx-53b614638ada36bb99f1.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="e8158fe77303107b8eb0";</script><script src="/webpack-runtime-38d5c81004aa5979d0dd.js" async></script><script src="/framework-9b6d338de49a676a1843.js" async></script><script src="/app-c3df7cc128b1fd8badc3.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>
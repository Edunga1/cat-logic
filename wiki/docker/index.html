<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 5.13.1"/><style data-href="/cat-logic/styles.7063392de47b3110fc97.css" data-identity="gatsby-global-css">code[class*=language-],pre[class*=language-]{word-wrap:normal;background:0 0;color:#000;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;-webkit-hyphens:none;hyphens:none;line-height:1.5;tab-size:4;text-align:left;text-shadow:0 1px #fff;white-space:pre;word-break:normal;word-spacing:normal}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{background:#b3d4fc;text-shadow:none}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{margin:.5em 0;overflow:auto;padding:1em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{border-radius:.3em;padding:.1em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{background:hsla(0,0%,100%,.5);color:#9a6e3a}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}*{box-sizing:border-box}body{margin:0}</style><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><style data-styled="" data-styled-version="5.3.11">.jKwTdT{box-sizing:border-box;background-color:#f5f5f5;padding:1rem 1rem 1rem 0;}/*!sc*/
.jKwTdT ul{list-style:none;padding-left:1rem;margin:0;font-size:.8rem;}/*!sc*/
.jKwTdT ul p{margin:0;}/*!sc*/
.jKwTdT a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g1[id="Toc__Container-sc-1f76i2s-0"]{content:"jKwTdT,"}/*!sc*/
.jzROSZ{overflow:auto;}/*!sc*/
.jzROSZ a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
.jzROSZ code:not(pre code){background-color:#f5f5f5;border-radius:.5rem;padding:.2rem .4rem;}/*!sc*/
.jzROSZ pre:has(code){font-size:85%;background-color:#f5f5f5;border-radius:.5rem;padding:1rem;overflow:auto;}/*!sc*/
.jzROSZ img{max-width:100%;}/*!sc*/
.jzROSZ blockquote{border-left:4px solid #ddd;padding-left:1rem;margin-left:0;font-style:italic;}/*!sc*/
data-styled.g2[id="WikiContent__Container-sc-q3jb6a-0"]{content:"jzROSZ,"}/*!sc*/
.gcJKrk{padding-top:20rem;}/*!sc*/
data-styled.g3[id="Comments__Container-sc-1ajj4d9-0"]{content:"gcJKrk,"}/*!sc*/
.gqosYh{display:grid;grid-template-columns:1fr;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;}/*!sc*/
@media (min-width:700px){.gqosYh{grid-template-columns:minmax(300px,1fr) minmax(400px,1000px);}}/*!sc*/
data-styled.g4[id="Wiki__Container-sc-16q9onf-0"]{content:"gqosYh,"}/*!sc*/
.hKa-dnq{display:none;}/*!sc*/
@media (min-width:700px){.hKa-dnq{display:block;}}/*!sc*/
data-styled.g5[id="Wiki__Side-sc-16q9onf-1"]{content:"hKa-dnq,"}/*!sc*/
.kXmPAY{padding:0 1rem;overflow:auto;}/*!sc*/
data-styled.g6[id="Wiki__Main-sc-16q9onf-2"]{content:"kXmPAY,"}/*!sc*/
.dSeHES{margin:0;padding:1rem 0 0 1rem;font-size:1rem;}/*!sc*/
data-styled.g7[id="Wiki__RelatedLinksHeader-sc-16q9onf-3"]{content:"dSeHES,"}/*!sc*/
.ikXvAQ{list-style:none;padding-left:1rem;margin:0;}/*!sc*/
.ikXvAQ > li{padding:0;line-height:1;}/*!sc*/
data-styled.g8[id="Wiki__RelatedLinks-sc-16q9onf-4"]{content:"ikXvAQ,"}/*!sc*/
</style><link rel="sitemap" type="application/xml" href="/cat-logic/sitemap-index.xml"/><title data-gatsby-head="true">Cat Logic - Docker</title></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="Wiki__Container-sc-16q9onf-0 gqosYh"><div class="Wiki__Side-sc-16q9onf-1 hKa-dnq"><div><div><h3 class="Wiki__RelatedLinksHeader-sc-16q9onf-3 dSeHES">Related Links</h3><ul class="Wiki__RelatedLinks-sc-16q9onf-4 ikXvAQ"><li><a href="../mac-os" style="font-size:0.5em;margin-right:0.5em">mac-os</a></li><li><a href="../windows-subsystem-for-linux" style="font-size:0.5em;margin-right:0.5em">windows-subsystem-for-linux</a></li><li><a href="../kubernetes" style="font-size:0.5em;margin-right:0.5em">kubernetes</a></li><li><a href="../tools" style="font-size:0.5em;margin-right:0.5em">tools</a></li><li><a href="../crontab" style="font-size:0.5em;margin-right:0.5em">crontab</a></li></ul></div></div></div><div class="Wiki__Main-sc-16q9onf-2 kXmPAY"><h1>Docker</h1><div class="Toc__Container-sc-1f76i2s-0 jKwTdT"><ul>
<li>
<p><a href="#docker">Docker</a></p>
<ul>
<li>
<p><a href="#docker-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0">Docker 환경 구성하기</a></p>
<ul>
<li><a href="#docker-desktop">Docker Desktop</a></li>
<li><a href="#rancher-desktop">Rancher Desktop</a></li>
<li><a href="#colima">Colima</a></li>
<li><a href="#osx-%EC%97%90%EC%84%9C-%EC%88%98%EB%8F%99%EC%9C%BC%EB%A1%9C-docker-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0">OSX 에서 수동으로 Docker 환경 구성하기</a></li>
</ul>
</li>
<li>
<p><a href="#dockerfile%EC%9D%98-volume-%EB%AA%85%EB%A0%B9%EC%96%B4">Dockerfile의 Volume 명령어</a></p>
</li>
<li>
<p><a href="#dockerfile">Dockerfile</a></p>
<ul>
<li><a href="#%EB%AA%85%EB%A0%B9%EC%96%B4">명령어</a></li>
</ul>
</li>
<li>
<p><a href="#%EC%A4%91%EC%A7%80%EB%90%9C-%EB%8F%84%EC%BB%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%97%90%EC%84%9C-%ED%8C%8C%EC%9D%BC-%EB%B3%B5%EC%82%AC%ED%95%98%EA%B8%B0">중지된 도커 컨테이너에서 파일 복사하기</a></p>
</li>
<li>
<p><a href="#jupyter-notebook--nodejs-%EB%8F%84%EC%BB%A4%EB%9D%BC%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%A1%9D">Jupyter Notebook + NodeJS 도커라이징 기록</a></p>
<ul>
<li><a href="#jupyter-docker-stacks">Jupyter Docker Stacks</a></li>
<li><a href="#end">End</a></li>
</ul>
</li>
<li>
<p><a href="#hostdockerinternal%EB%A1%9C-%ED%98%B8%EC%8A%A4%ED%8A%B8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0"><code class="language-text">host.docker.internal</code>로 호스트 서비스 접근하기</a></p>
<ul>
<li><a href="#%EB%8C%80%EC%B2%B4%EB%8A%94">대체는?</a></li>
</ul>
</li>
<li>
<p><a href="#%EB%A7%A5%EB%B6%81-m2-%EC%9D%B4%EC%8A%88">맥북 m2 이슈</a></p>
<ul>
<li><a href="#mysql56">mysql:5.6</a></li>
</ul>
</li>
<li>
<p><a href="#references">References</a></p>
</li>
</ul>
</li>
</ul></div><div class="WikiContent__Container-sc-q3jb6a-0 jzROSZ">
<h2 id="docker-환경-구성하기" style="position:relative;"><a href="#docker-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0" aria-label="docker 환경 구성하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Docker 환경 구성하기</h2>
<p>여러가지 선택지가 있으나 MacOS, Linux라면 Colima를 가장 추천한다.
WSL2는 Rancher Desktop 추천.</p>
<h3 id="docker-desktop" style="position:relative;"><a href="#docker-desktop" aria-label="docker desktop permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Docker Desktop</h3>
<p><a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a></p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">brew <span class="token function">install</span> <span class="token parameter variable">--cask</span> <span class="token function">docker</span></code></pre></div>
<p>가장 쉽게 Docker를 사용할 수 있는 방법이다.
개인 사용자는 무료로 사용할 수 있다.
라이센스 정책 변경으로 인해 <a href="https://www.docker.com/pricing/faq/">기업 사용자는 조건</a>에 따라 유료로 사용해야 한다.</p>
<h3 id="rancher-desktop" style="position:relative;"><a href="#rancher-desktop" aria-label="rancher desktop permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rancher Desktop</h3>
<p><a href="https://rancherdesktop.io/">https://rancherdesktop.io/</a></p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">brew <span class="token function">install</span> <span class="token parameter variable">--cask</span> rancher</code></pre></div>
<p>Docker Desktop과 흡사하다. 기본적으로 <a href="../kubernetes">k8s</a> 제공한다.
불필요 하다면 끄는 편이 리소스 절약에 좋다.
container runtime을 containerd, dockerd 중 선택할 수 있는데, docker에 익숙하면 dockerd를 선택하는 것이 좋다.</p>
<p>개인 사용자더라도 docker desktop의 라이센스 정책이 불편하니 그냥 rancher desktop을 사용하는 것이 좋을지도.</p>
<p>WSL2을 잘 지원한다.</p>
<h3 id="colima" style="position:relative;"><a href="#colima" aria-label="colima permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Colima</h3>
<p><a href="https://github.com/abiosoft/colima/">https://github.com/abiosoft/colima/</a></p>
<p>Linux, MacOS 모두 지원한다.
최소한의 설정으로 컨테이너를 제공한다고 설명한다:</p>
<blockquote>
<p>Container runtimes on macOS (and Linux) with minimal setup</p>
</blockquote>
<p>MacOs는 homebrew로 쉽게 설치할 수 있다: <code class="language-text">brew install colima</code></p>
<p><a href="https://github.com/abiosoft/colima/issues/434">아직 WSL2를 지원하지 않으니</a> 주의.
<a href="https://github.com/lima-vm/">Lima</a>라는 가상머신 지원 도구를 사용하는데, 아직 윈도우를 지원하지 않아서 colima도 제공할 수 없다는 듯. 조만간 WSL도 제공할 수 있을 거 같다고 하니 기다려 보자.</p>
<p>Command line으로만 도커를 시작할 수 있다.
GUI를 제공하지 않지만 Docker Desktop이나 Rancher Desktop에서도 GUI를 잘 사용하지 않으니 딱히 문제는 안된다.</p>
<p><code class="language-text">colima</code> 명령어를 제공하고, <code class="language-text">colima start</code>로 도커를 시작한다.
다만 기본으로 memory가 <code class="language-text">2</code>GiB로 설정되는데, 메모리 문제로 <a href="https://github.com/marclamberti/docker-airflow/blob/main/docker-compose.yml">airflow 컨테이너</a>가 시작하자마자 죽는 문제가 있었다.</p>
<p><code class="language-text">colima start --memory 8 --cpu 4</code>와 같이 자원 할당을 늘려서 시작할 수 있다.</p>
<p>현재 자원 할당 상태를 보려면 <code class="language-text">colima status -e</code>:</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">❯ colima status <span class="token parameter variable">-e</span>
INFO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> colima is running using QEMU
INFO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> arch: aarch64
INFO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> runtime: <span class="token function">docker</span>
INFO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> mountType: sshfs
INFO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> socket: unix:///Users/alleb/.colima/default/docker.sock
INFO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> networkDriver: gvproxy
INFO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> cpu: <span class="token number">2</span>
INFO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> mem: 8GiB
INFO<span class="token punctuation">[</span>0000<span class="token punctuation">]</span> disk: 60GiB</code></pre></div>
<h3 id="osx-에서-수동으로-docker-환경-구성하기" style="position:relative;"><a href="#osx-%EC%97%90%EC%84%9C-%EC%88%98%EB%8F%99%EC%9C%BC%EB%A1%9C-docker-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0" aria-label="osx 에서 수동으로 docker 환경 구성하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>OSX 에서 수동으로 Docker 환경 구성하기</h3>
<p><strong>docker desktop 또는 rancher desktop이 나와서 이 방법은 비추천.</strong></p>
<p><strong>1. Homebrew로 Docker와 Docker-machine 설치</strong></p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ brew <span class="token function">install</span> <span class="token function">docker</span> docker-machine</code></pre></div>
<p>docker-machine: 맥을 마치 Host OS 처럼 사용 할 수 있도록 해주는 프로그램</p>
<p><strong>2. Homebrew로 Virtualbox 설치</strong></p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ brew cask <span class="token function">install</span> virtualbox</code></pre></div>
<p>Virtualbox: 가상화 프로그램. 맥에서 docker-machine(Host OS, Linux)을 운영하기 위해서 사용</p>
<p><strong>3. docker-machine 설정</strong></p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ docker-machine create <span class="token parameter variable">-d</span> virtualbox default</code></pre></div>
<p>virtualbox driver를 이용하여 <code class="language-text">default</code> 이름의 Docker-machine을 생성</p>
<p>virtualbox에 Docker-machine이 올라간다.</p>
<p><strong>4. 생성한 Docker-machine 활성화</strong></p>
<p>Docker-machine을 생성했지만, 아직 <code class="language-text">docker</code> 명령어를 이용할 수 없다.</p>
<p>Docker-machine을 여러개 관리할 수 있다. 따라서 사용하고자 하는 Docker-machine을 활성화해야 한다.</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ docker-machine <span class="token function">ls</span>
NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS
default   -        virtualbox   Running   tcp://192.168.99.100:2376           v17.03.0-ce

$ docker-machine <span class="token function">env</span> default
<span class="token builtin class-name">export</span> <span class="token assign-left variable">DOCKER_TLS_VERIFY</span><span class="token operator">=</span><span class="token string">"1"</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">DOCKER_HOST</span><span class="token operator">=</span><span class="token string">"tcp://192.168.99.100:2376"</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">DOCKER_CERT_PATH</span><span class="token operator">=</span><span class="token string">"/Users/parkdu/.docker/machine/machines/default"</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable">DOCKER_MACHINE_NAME</span><span class="token operator">=</span><span class="token string">"default"</span>
<span class="token comment">## Run this command to configure your shell:</span>
<span class="token comment">## eval $(docker-machine env default)</span></code></pre></div>
<p>위 명령어로 <code class="language-text">default</code> Docker-machine의 환경 정보를 알 수 있다.</p>
<p>그리고 마지막 <code class="language-text">eval</code> 명령어로 활성화 할 수 있다.</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">$ <span class="token builtin class-name">eval</span> <span class="token variable"><span class="token variable">$(</span>docker-machine <span class="token function">env</span> default<span class="token variable">)</span></span>
$ docker-machine <span class="token function">ls</span>
NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS
default   *        virtualbox   Running   tcp://192.168.99.100:2376           v17.03.0-ce</code></pre></div>
<p>ACTIVE 속성이 <code class="language-text">*</code>로 변경되었다.</p>
<p>이제 맥에서 <code class="language-text">docker</code> 명령어를 사용할 수 있다!</p>
<h2 id="dockerfile의-volume-명령어" style="position:relative;"><a href="#dockerfile%EC%9D%98-volume-%EB%AA%85%EB%A0%B9%EC%96%B4" aria-label="dockerfile의 volume 명령어 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dockerfile의 Volume 명령어</h2>
<p>다음과 같이 컨테이너를 띄우면 <code class="language-text">docker run -ti --rm -v $(pwd):/myvol --name foo ubuntu</code>
현재 디렉토리를 컨테이너와 공유하여 사용할 수 있다.</p>
<p>그런데 <strong>Dockerfile</strong> 내에서 <code class="language-text">VOLUME</code> 키워드를 사용하면 호스트를 지정해 줄 수 없다.</p>
<p>그리고 호스트의 디렉토리를 생략하여 <code class="language-text">-v</code> 옵션을 줄 수 있다: <code class="language-text">docker run -ti --rm -v /myvol --name foo ubuntu</code></p>
<p>이는 컨테이너의 경로만 지정한 것이 된다.</p>
<p><code class="language-text">docker inspect</code>로 보면 호스트의 디렉토리(<code class="language-text">source</code>)는 이상한 곳에 연결되어 있다:</p>
<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token property">"Mounts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
        <span class="token property">"Type"</span><span class="token operator">:</span> <span class="token string">"volume"</span><span class="token punctuation">,</span>
        <span class="token property">"Name"</span><span class="token operator">:</span> <span class="token string">"922a144309641e2cb18e84498b6b3b5f7f55eacd8073b37062b1dc50cc568814"</span><span class="token punctuation">,</span>
        <span class="token property">"Source"</span><span class="token operator">:</span> <span class="token string">"/var/lib/docker/volumes/922a144309641e2cb18e84498b6b3b5f7f55eacd8073b37062b1dc50cc568814/_data"</span><span class="token punctuation">,</span>
        <span class="token property">"Destination"</span><span class="token operator">:</span> <span class="token string">"/myvol"</span><span class="token punctuation">,</span>
        <span class="token property">"Driver"</span><span class="token operator">:</span> <span class="token string">"local"</span><span class="token punctuation">,</span>
        <span class="token property">"Mode"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
        <span class="token property">"RW"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token property">"Propagation"</span><span class="token operator">:</span> <span class="token string">""</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span><span class="token punctuation">,</span></code></pre></div>
<p>이건 어디다 어떻게 쓰는가?</p>
<p><strong>컨테이너간 데이터 공유</strong> 위해서 사용한다.</p>
<ol>
<li><code class="language-text">foo</code> 컨테이너를 띄운다:<br></li>
</ol>
<p><code class="language-text">docker run -ti --rm -v /myvol --name foo ubuntu</code></p>
<ol start="2">
<li>그리고 <code class="language-text">foo</code> 컨테이너와 데이터를 함께 사용할 <code class="language-text">bar</code>를 띄운다:<br></li>
</ol>
<p><code class="language-text">docker run -ti --rm --volumes-from foo --name bar ubuntu</code></p>
<ol start="3">
<li><code class="language-text">foo</code>와 <code class="language-text">bar</code> 내에서 볼륨 연결된 디렉토리가 비어있음을 확인한다:<br></li>
</ol>
<p><code class="language-text">ls myvol</code></p>
<ol start="4">
<li><code class="language-text">foo</code>에서 <code class="language-text">text</code> 라는 파일을 생성해본다:<br></li>
</ol>
<p><code class="language-text">touch myvol/text</code></p>
<ol start="5">
<li><code class="language-text">bar</code>에도 <code class="language-text">myvol/text</code> 라는 파일이 생성되었음을 확인한다:<br></li>
</ol>
<p><code class="language-text">ls myvol</code></p>
<p>즉, 호스트 디렉토리 연결 없이 볼륨을 사용한다면 <code class="language-text">--volumes-from</code> 옵션을 사용하는 컨테이너가 있음을 의미한다.</p>
<h2 id="dockerfile" style="position:relative;"><a href="#dockerfile" aria-label="dockerfile permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dockerfile</h2>
<p>도커 이미지를 빌드하기 위한 명령어들을 모아놓은 파일.</p>
<p>스크립트로 이루어져 있기 때문에 이미지를 관리하는 것보다 훨씬 비용이 적게 든다는 장점이 있다.</p>
<p>각 명령어 마다 이전 이미지로부터 새로운 이미지를 생성한다.(Layer)</p>
<h3 id="명령어" style="position:relative;"><a href="#%EB%AA%85%EB%A0%B9%EC%96%B4" aria-label="명령어 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>명령어</h3>
<p><strong>CMD</strong></p>
<p>컨테이너 시작 시 실행 할 명령어</p>
<ul>
<li><code class="language-text">CMD &lt;command></code></li>
<li><code class="language-text">CMD ["executable","param1","param2"]</code></li>
</ul>
<p><strong>RUN</strong></p>
<p>빌드 시 실행할 명령어, 일반적으로 이미지의 환경을 구성하는데 사용한다.</p>
<ul>
<li><code class="language-text">RUN &lt;command></code></li>
<li><code class="language-text">RUN ["executable", "param1", "param2"]</code></li>
<li><code class="language-text">RUN apt-get install -y nodejs</code></li>
</ul>
<p><strong>ENV</strong></p>
<p>환경 변수 설정. RUN, CMD 명령어 모두에서 영향을 받는다.</p>
<ul>
<li><code class="language-text">ENV &lt;key> &lt;value></code></li>
<li><code class="language-text">ENV &lt;key>=&lt;value></code></li>
</ul>
<p><strong>WORKDIR</strong></p>
<p>작업 디렉토리 설정. RUN, CMD 명령어의 실행 위치를 설정한다.</p>
<ul>
<li><code class="language-text">WORKDIR &lt;path></code></li>
</ul>
<p><a href="https://docs.docker.com/engine/reference/builder/#add">ADD</a> or <a href="https://docs.docker.com/engine/reference/builder/#copy">COPY</a></p>
<p>호스트의 파일을 이미지에 추가.</p>
<ul>
<li><code class="language-text">ADD &lt;src> &lt;dest></code></li>
<li><code class="language-text">ADD &lt;git ref> &lt;dir></code> git 저장소에서 파일을 가져온다.</li>
</ul>
<p><a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#add-or-copy">ADD와 COPY 차이점</a>:</p>
<blockquote>
<p>Although ADD and COPY are functionally similar, generally speaking, COPY is preferred. That’s because it’s more transparent than ADD. COPY only supports the basic copying of local files into the container, while ADD has some features (like local-only tar extraction and remote URL support) that are not immediately obvious. Consequently, the best use for ADD is local tar file auto-extraction into the image, as in ADD rootfs.tar.xz /.</p>
</blockquote>
<p>Best Practice 문서에서 설명하기를, 기능 자체는 비슷하나 일반적(파일 복사)으로 <code class="language-text">COPY</code>를 선호한다. 더 명확하기 때문이다.
<code class="language-text">ADD</code>에는 추가 기능이 있는데, tar 파일 압축 해제나 원격 URL 지원, git 저장소를 추가할 수 있다.</p>
<p><a href="https://docs.docker.com/engine/reference/builder/#expose">EXPOSE</a></p>
<blockquote>
<p>The EXPOSE instruction does not actually publish the port. It functions as a type of documentation between the person who builds the image and the person who runs the container, about which ports are intended to be published.</p>
</blockquote>
<p><code class="language-text">EXPOSE</code>는 포트를 실제로 열지 않는다. 이미지 빌드하는 사람과 컨테이너를 실행하는 사람 사이의 문서 역할을 한다.
<code class="language-text">-p</code> 옵션으로 포트를 열거나, docker-compose의 <code class="language-text">ports</code>를 사용하여 포트를 열자.</p>
<p><code class="language-text">EXPOSE</code>를 주면, 컨테이너를 생성하여 <code class="language-text">docker ps</code>로 컨테이너를 확인했을 때 <code class="language-text">PORTS</code> 열에 포트 정보가 표시된다.</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">CONTAINER ID        IMAGE                          COMMAND                  CREATED             STATUS              PORTS                                                            NAMES
9f8fa8cbf88c        grokzen/redis-cluster:latest   <span class="token string">"/docker-entrypoint.…"</span>   <span class="token number">27</span> minutes ago      Up <span class="token number">27</span> minutes       <span class="token number">5000</span>-5002/tcp, <span class="token number">6379</span>/tcp, <span class="token number">7001</span>-7007/tcp, <span class="token number">0.0</span>.0.0:6379-<span class="token operator">></span><span class="token number">7000</span>/tcp   redis-cluster</code></pre></div>
<p>여기서 <code class="language-text">5000-5002/tcp, 6379/tcp, 7001-7007/tcp</code>는 <code class="language-text">EXPOSE</code>로 명세했지만 호스트와 바인딩되지 않았음을 의미한다.
즉, <code class="language-text">EXPOSE</code>는 포트 대기중을 의미한다.</p>
<h2 id="중지된-도커-컨테이너에서-파일-복사하기" style="position:relative;"><a href="#%EC%A4%91%EC%A7%80%EB%90%9C-%EB%8F%84%EC%BB%A4-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%97%90%EC%84%9C-%ED%8C%8C%EC%9D%BC-%EB%B3%B5%EC%82%AC%ED%95%98%EA%B8%B0" aria-label="중지된 도커 컨테이너에서 파일 복사하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>중지된 도커 컨테이너에서 파일 복사하기</h2>
<p><code class="language-text">docker ps -a</code>로 중지된 컨테이너가 있다면 그 컨테이너로부터 파일을 호스트로 복사해올 수 있다</p>
<p><code class="language-text">docker cp 컨테이너:경로 호스트경로</code>로 복사한다.<br>
컨테이너와 호스트를 반대로 입력하여 중지된 컨테이너에 파일을 주입할 수도 있을 거 같다.</p>
<p>반면 <code class="language-text">docker exec</code>는 중지된 컨테이너에 접속할 수 없다.</p>
<hr>
<p>ionic으로 빌드를 하고, jarsginer로 서명까지하여 릴리즈 apk를 만드는 도커파일을 작성했다.<br>
그리고 apk를 생성하면 컨테이너는 종료된다.<br>
젠킨스에 등록하여 master 브랜치가 업데이트 될 때마다 apk를 뽑아서, GCP bucket에 업로드하도록 작성했다.<br></p>
<p>처음엔 볼륨을 연결하여 호스트에 생성되도록 했으나 <code class="language-text">mkdir /root/workspace: read-only file system.</code>에러가 뜬다.<br>
젠킨스 slave의 문제인지. 어차피 볼륨으로 뿜어내는 방식이 내키지 않아서 다른 방식을 찾았다.<br>
무한 루프를 돌도록해서 컨테이너가 죽지 않도록하여 복사해올까 하다가, 중지된 컨테이너에서 가져올 수 있었다.</p>
<p>중지된 컨테이너가 다른 컨테이너에 볼륨을 공유하는 data-only 패턴과 비슷한 방식인듯?</p>
<h2 id="jupyter-notebook--nodejs-도커라이징-기록" style="position:relative;"><a href="#jupyter-notebook--nodejs-%EB%8F%84%EC%BB%A4%EB%9D%BC%EC%9D%B4%EC%A7%95-%EA%B8%B0%EB%A1%9D" aria-label="jupyter notebook  nodejs 도커라이징 기록 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Jupyter Notebook + NodeJS 도커라이징 기록</h2>
<p>Jupyter Notebook이 너무 유용한 거 같아서 NodeJS도 쓰고 싶어졌다.</p>
<ol>
<li>
<p>찾아보니 기존 Jupyter 환경에 npm <code class="language-text">ijavascript</code>라는 cli를 설치하면 기존 Python에 NodeJS 노트까지 추가할 수 있었다.</p>
</li>
<li>
<p>하지만 python, nodejs 관련 모듈을 설치하면 너무 복잡해져서 나중에 다시 환경 구성하기 힘들 거 같아서</p>
</li>
</ol>
<p>도커 쪽으로 눈길을 돌렸다.</p>
<ol>
<li>찾아보니 Python, Go, NodeJs 모두 가능한 도커 이미지를 찾았다:</li>
</ol>
<p><a href="https://github.com/dting/docker-jupyter-go-js">https://github.com/dting/docker-jupyter-go-js</a><br>
오피셜(docker hub 말고) Jupyter Notebook 이미지를 base로 작성된
Go 언어 용 Jupyter 이미지를 base로 작성된 도커 이미지였다. (음)</p>
<ol>
<li>문제는 오래된 이미지다 보니 node 버전도 낮고, pip 버전도 낮아서</li>
</ol>
<p><a href="https://facebook.github.io/prophet/docs/quick_start.html">fbprophet</a>
모듈이 설치가 안되었다. Dockerfile을 복사해서 다시 이미지를 빌드하려 했으나
지금은 사라진 <code class="language-text">jupyter/notebook</code>이라는 이미지를 base로 하고 있어서 다시 작성하기 어려웠다.</p>
<ol>
<li>좀 더 찾아보다가 <a href="https://hub.docker.com/r/mfellner/javascript-notebook">https://hub.docker.com/r/mfellner/javascript-notebook</a> 이미지를 찾았다.</li>
</ol>
<p>오래 되었지만, 지금도 관리되고 있는 <code class="language-text">jupyter/minimal-notebook</code>를
base로 하고 있어서, 참고하여 Dockerfile을 다시 작성하기로 했다.</p>
<ol>
<li><code class="language-text">mfellner/javascript-notebook</code> Dockerfile을 수정해서 nodejs 버전을 올리고</li>
</ol>
<p><code class="language-text">6.0.0</code> -> <code class="language-text">10.15.3</code> 빌드했다.</p>
<ol>
<li>실행은 잘 되나, 최초 연결 시 비밀번호/토큰을 입력해야 했다.</li>
</ol>
<p>어차피 로컬에서만 사용할거라 불필요하다고 판단돼서, jupyter notebook 옵션인
<code class="language-text">--NotebookApp.token=''</code>을 시작 스크립트인 <code class="language-text">start-notebook.sh</code>에 주었으나,
<code class="language-text">mfellner/javascript-notebook</code>에서 원본 스크립트를 <code class="language-text">ijavascript</code> 실행 명령어로 덮어 씌우고 있어서,
적용되지 않고 계속 토큰을 입력해야 했다.</p>
<ol>
<li>
<p>그래서 덮어 씌우는 부분을 Dockerfile에서 제거하고 빌드했으나, 언어 목록에서 nodejs가 제외되었다. 찾아보니</p>
<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"argv"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">"node"</span><span class="token punctuation">,</span>
    <span class="token string">"/usr/local/lib/node_modules/ijavascript/lib/kernel.js"</span><span class="token punctuation">,</span>
    <span class="token string">"{connection_file}"</span><span class="token punctuation">,</span>
    <span class="token string">"--protocol=5.0"</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">"display_name"</span><span class="token operator">:</span> <span class="token string">"Javascript (Node.js)"</span><span class="token punctuation">,</span>
  <span class="token property">"language"</span><span class="token operator">:</span> <span class="token string">"javascript"</span>
<span class="token punctuation">}</span></code></pre></div>
<p>커널 정보를 이런 포맷으로, Jupyter Notebook의 특정 위치에 두어야 언어 목록에서 출력되는 것이었다.
<code class="language-text">ijavascript</code>는 <code class="language-text">ijsinstall</code>이라는 명령어로 환경 구성을 할 때 <code class="language-text">json</code> 파일을 추가도 해 주고 있었다:
<a href="https://github.com/n-riesco/ijavascript/blob/d459956f76a22f9ec89937e02645ee7555f92d2b/bin/rc.js#L525">https://github.com/n-riesco/ijavascript/blob/d459956f76a22f9ec89937e02645ee7555f92d2b/bin/rc.js#L525</a></p>
</li>
<li>
<p>그래서 간단하게 <code class="language-text">RUN ijsinstall</code> 해 줘서, 원본 <code class="language-text">start-notebook.sh</code>는 수정하지 않아도 잘 실행되도록 했다.</p>
</li>
</ol>
<h3 id="jupyter-docker-stacks" style="position:relative;"><a href="#jupyter-docker-stacks" aria-label="jupyter docker stacks permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Jupyter Docker Stacks</h3>
<p>Jupyter Notebook의 도커 버전은 상당히 많은 시리즈로 되어 있다.
도커 허브엔 설명이 적고 GitHub: <a href="https://github.com/jupyter/docker-stacks">https://github.com/jupyter/docker-stacks</a> 에 메뉴얼이 잘 되어 있다.</p>
<p>Dockerfile 관계 트리를 보면 멋있다:<br>
<a href="http://interactive.blockdiag.com/?compression=deflate&#x26;src=eJyFzTEPgjAQhuHdX9Gws5sQjGzujsaYKxzmQrlr2msMGv-71K0srO_3XGud9NNA8DSfgzESCFlBSdi0xkvQAKTNugw4QnL6GIU10hvX-Zh7Z24OLLq2SjaxpvP10lX35vCf6pOxELFmUbQiUz4oQhYzMc3gCrRt2cWe_FKosmSjyFHC6OS1AwdQWCtyj7sfh523_BI9hKlQ25YdOFdv5fcH0kiEMA">http://interactive.blockdiag.com/?compression=deflate&#x26;src=eJyFzTEPgjAQhuHdX9Gws5sQjGzujsaYKxzmQrlr2msMGv-71K0srO_3XGud9NNA8DSfgzESCFlBSdi0xkvQAKTNugw4QnL6GIU10hvX-Zh7Z24OLLq2SjaxpvP10lX35vCf6pOxELFmUbQiUz4oQhYzMc3gCrRt2cWe_FKosmSjyFHC6OS1AwdQWCtyj7sfh523_BI9hKlQ25YdOFdv5fcH0kiEMA</a></p>
<p>커스터마이징하려면 <code class="language-text">jupyter/notebook-minimal</code>을 기반으로 하면 될 거 같다.</p>
<p><a href="https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html#jupyter-base-notebook">https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html#jupyter-base-notebook</a>
여기에 데이터과학, 머신러닝 등 각 분야에 자주 사용하는 모듈을 미리 설치한 이미지들 정보가 나와있다.</p>
<h3 id="end" style="position:relative;"><a href="#end" aria-label="end permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>End</h3>
<p>Jupyter Notebook NodeJS 도커라이징한 것은 여기에 올렸다:<br>
<a href="https://github.com/Edunga1/jupyter-notebook-nodejs">https://github.com/Edunga1/jupyter-notebook-nodejs</a></p>
<p>Dockerfile 작성하면서 <code class="language-text">MAINTAINER</code>가 deprecated, <code class="language-text">LABEL</code>을 사용해야 하는 것을 알았다: <a href="https://stackoverflow.com/questions/38899977/how-do-i-declare-multiple-maintainers-in-my-dockerfile">https://stackoverflow.com/questions/38899977/how-do-i-declare-multiple-maintainers-in-my-dockerfile</a></p>
<h2 id="hostdockerinternal로-호스트-서비스-접근하기" style="position:relative;"><a href="#hostdockerinternal%EB%A1%9C-%ED%98%B8%EC%8A%A4%ED%8A%B8-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%A0%91%EA%B7%BC%ED%95%98%EA%B8%B0" aria-label="hostdockerinternal로 호스트 서비스 접근하기 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code class="language-text">host.docker.internal</code>로 호스트 서비스 접근하기</h2>
<p><code class="language-text">host.docker.internal</code>은 호스트의 ip를 가르키는 DNS name이다.
<a href="https://docs.docker.com/desktop/networking/#i-want-to-connect-from-a-container-to-a-service-on-the-host">container에서 호스트의 서비스에 접근</a>이 필요할 때 사용한다.</p>
<blockquote>
<p>This is for development purpose and does not work in a production environment outside of Docker Desktop.</p>
</blockquote>
<p>주의할 점은 <strong>docker-desktop</strong> 에서 제공하는 것이다. rancher-desktop 등 다른 도구로 docker 구성했다면 사용할 수 없다.</p>
<h3 id="대체는" style="position:relative;"><a href="#%EB%8C%80%EC%B2%B4%EB%8A%94" aria-label="대체는 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>대체는?</h3>
<p><code class="language-text">docker</code> 명령어:</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash"><span class="token function">docker</span> run --add-host<span class="token operator">=</span>host.docker.internal:host-gateway</code></pre></div>
<p><code class="language-text">docker-compose.yml</code>:</p>
<div class="gatsby-highlight" data-language="yaml"><pre class="language-yaml"><code class="language-yaml"><span class="token key atrule">my_app</span><span class="token punctuation">:</span>
  <span class="token key atrule">extra_hosts</span><span class="token punctuation">:</span>
    <span class="token punctuation">-</span> <span class="token string">"host.docker.internal:host-gateway"</span></code></pre></div>
<p>반드시 <code class="language-text">host.docker.internal</code> 필요는 없다. 편한 것으로 수정하면 된다.</p>
<p><code class="language-text">host-gateway</code>의 정보는 잘 모르겠다. 가상화 도구 중 <code class="language-text">dockerd</code>만 제공하는 것으로 보인다.</p>
<p><code class="language-text">dockerd</code> cli 문서만 있고, 간단하게 설명되어 있다:</p>
<p><a href="https://docs.docker.com/engine/reference/commandline/dockerd/">https://docs.docker.com/engine/reference/commandline/dockerd/</a></p>
<blockquote>
<p>--host-gateway-ip ip
IP address that the special 'host-gateway' string in --add-host resolves to.
Defaults to the IP address of the default bridge</p>
</blockquote>
<h2 id="맥북-m2-이슈" style="position:relative;"><a href="#%EB%A7%A5%EB%B6%81-m2-%EC%9D%B4%EC%8A%88" aria-label="맥북 m2 이슈 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>맥북 m2 이슈</h2>
<p>Intel CPU(amd64) -> M2(arm)로 옮기면서 발생한 문제</p>
<h3 id="mysql56" style="position:relative;"><a href="#mysql56" aria-label="mysql56 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>mysql:5.6</h3>
<p>mysql 8 버전 이하는 arm64 용으로<a href="https://hub.docker.com/r/arm64v8/mysql/">제공하지 않는 것</a>으로 보인다.
그래서 <code class="language-text">docker pull mysql:5.6</code> 하면 manifest를 찾을 수 없다며 실패한다:</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">❯ <span class="token function">docker</span> pull mysql:5.6
<span class="token number">5.6</span>: Pulling from library/mysql
no matching manifest <span class="token keyword">for</span> linux/arm64/v8 <span class="token keyword">in</span> the manifest list entries</code></pre></div>
<p>해결을 위해선 그냥 amd64 것을 사용해도 동작하므로 <code class="language-text">--platform</code> 옵션을 줘서 amd64 것으로 받는다:</p>
<div class="gatsby-highlight" data-language="bash"><pre class="language-bash"><code class="language-bash">❯ <span class="token function">docker</span> pull <span class="token parameter variable">--platform</span> linux/amd64 mysql:5.6</code></pre></div>
<h2 id="references" style="position:relative;"><a href="#references" aria-label="references permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>References</h2>
<p>NodeJS 어플리케이션의 Dockerizing<br>
<a href="https://nodejs.org/en/docs/guides/nodejs-docker-webapp/">https://nodejs.org/en/docs/guides/nodejs-docker-webapp/</a></p></div><div class="Comments__Container-sc-1ajj4d9-0 gcJKrk"><hr/><div></div></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/wiki/docker/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-adf0ad85d5744a13b71d.js\"],\"component---src-components-gatsby-templates-wiki-tsx\":[\"/component---src-components-gatsby-templates-wiki-tsx-5c2e2980702c72fc27d4.js\"],\"component---src-pages-404-tsx\":[\"/component---src-pages-404-tsx-8f631674f884ce01bddf.js\"],\"component---src-pages-index-tsx\":[\"/component---src-pages-index-tsx-f6ed90c5ec297fc14e0e.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="ed0d14045f6b8a176af6";</script><script src="/cat-logic/webpack-runtime-b9e17581036125160ba2.js" async></script><script src="/cat-logic/app-adf0ad85d5744a13b71d.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>
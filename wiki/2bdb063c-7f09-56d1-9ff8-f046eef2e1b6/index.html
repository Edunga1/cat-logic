<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 5.6.0"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div><div><ul>
<li>
<p><a href="#node-js">Node JS</a></p>
</li>
<li>
<p><a href="#nodejs-test-tools">NodeJS Test Tools</a></p>
<ul>
<li><a href="#mocha---framework">Mocha - Framework</a></li>
<li><a href="#chai---library">Chai - Library</a></li>
<li><a href="#istanbul---coverage-tool">Istanbul - Coverage Tool</a></li>
</ul>
</li>
<li>
<p><a href="#proxyquire">Proxyquire</a></p>
<ul>
<li>
<p><a href="#proxyquire-%EB%AA%A8%EB%93%88-%EB%A1%9C%EB%93%9C-%EC%88%9C%EC%84%9C-%EB%AC%B8%EC%A0%9C">proxyquire 모듈 로드 순서 문제</a></p>
<ul>
<li><a href="#requireproxyquirenopreservecache-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0"><code>require('proxyquire').noPreserveCache()</code> 사용하기</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#proxyquire-vs-rewire">Proxyquire vs. rewire</a></p>
<ul>
<li>
<p><a href="#%EC%96%B4%EB%96%A4-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EC%9E%88%EC%9D%84%EA%B9%8C">어떤 차이가 있을까?</a></p>
<ul>
<li><a href="#rewire-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8C%80%EC%83%81-%EB%82%B4%EC%97%90-%EC%84%A0%EC%96%B8%ED%95%9C-%EB%B3%80%EC%88%98%EB%A5%BC-%EA%B0%80%EB%A1%9C%EC%B1%84%EC%96%B4-%EB%B0%94%EA%BE%BC%EB%8B%A4">rewire: 테스트 대상 내에 선언한 변수를 가로채어 바꾼다.</a></li>
<li><a href="#proxyquire-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%8C%80%EC%83%81%EC%9D%B4-require%ED%95%98%EB%8A%94-%EB%AA%A8%EB%93%88%EC%9D%84-%EB%B0%94%EA%BF%94%EC%84%9C-%EB%B3%B4%EB%82%B4%EC%A4%80%EB%8B%A4">proxyquire: 테스트 대상이 <code>require</code>하는 모듈을 바꿔서 보내준다.</a></li>
</ul>
</li>
<li>
<p><a href="#rewire-%EC%A0%9C%ED%95%9C%EC%82%AC%ED%95%AD">rewire 제한사항</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#sinonjs">Sinon.JS</a></p>
<ul>
<li><a href="#new-date-%EC%A1%B0%EC%9E%91%ED%95%98%EA%B8%B0"><code>new Date()</code> 조작하기</a></li>
</ul>
</li>
<li>
<p><a href="#nodejs-data-validation">NodeJS data validation</a></p>
</li>
<li>
<p><a href="#nodejs-%EC%84%9C%EB%B2%84-%EB%A1%9C%EC%BB%AC-%EC%9A%94%EC%B2%AD%EB%A7%8C-%ED%97%88%EC%9A%A9%ED%95%98%EA%B8%B0">NodeJS 서버 로컬 요청만 허용하기</a></p>
</li>
<li>
<p><a href="#pm2-deploy-%EC%8B%9C-%EC%A3%BC%EC%9D%98%ED%95%A0-%EC%A0%90">pm2 deploy 시 주의할 점</a></p>
</li>
<li>
<p><a href="#jupyter-notebook-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0">Jupyter notebook 사용하기</a></p>
</li>
<li>
<p><a href="#taming-architecture-complexity-in-v8">Taming architecture complexity in v8</a></p>
</li>
</ul></div><div><h1>Node JS</h1>
<p>node.js로 개발을 하고있지 않아서.. 대부분 내용이 2016년 정도에 머물러 있다.</p>
<h1>NodeJS Test Tools</h1>
<p>지금은 <a href="https://github.com/facebook/jest">Jest</a>를 사용하고 있다.
이거 하나면 대부분 가능하더라.</p>
<h2>Mocha - Framework</h2>
<p>테스트 구조를 제공한다.</p>
<p>설치 : <code>npm install mocha --save-dev</code></p>
<p>테스트 스크립트 실행 : <code>mocha &#x3C;PATH></code></p>
<pre><code class="language-javascript">describe('어떤 테스트를 할 것인지 대략적인 설명', function () {

    beforeEach(function () {
        // 매 it() 마다 실행 할 코드
    });

    it('테스트 단위 별 설명', function () {
        // 여기에 Assertion 코드를 둔다.
    });
});
</code></pre>
<h2>Chai - Library</h2>
<p>Assertion 라이브러리. 값 비교에 사용한다.</p>
<p>설치 : <code>npm install chai --save-dev</code></p>
<pre><code class="language-javascript">describe('어떤 테스트를 할 것인지 대략적인 설명', function () {

    it('테스트 단위 별 설명', function () {
        // 여기에 Assertion 코드를 둔다.
        var foo = 'foo';
        expect(foo).to.equal('foo'); // 통과
        expect(foo).to.equal('bar'); // 값이 다르므로 통과하지 못함
    });
});
</code></pre>
<h2>Istanbul - Coverage Tool</h2>
<p>코드 커버리지. 내 <strong>테스트 코드</strong>가 <strong>모듈의 어디까지 테스트하는지 측정</strong> 하는데 사용한다.</p>
<p>테스트 시 <code>coverage/</code> 폴더가 생성되어 리포트 페이지(html)를 생성한다. 여기서 실제 모듈이 얼마나 호출 되었는지, 어디가 문맥상 접근하지 않았는지 알 수 있다.</p>
<p>설치 : <code>npm install istanbul --save-dev</code></p>
<p>Mocha와 함께 실행 : <code>istanbul cover _mocha</code> (<code>_mocha</code>인 이유는 Mocha의 프로세스 이름을 이용하기 때문)</p>
<p>별도의 코드는 없다.</p>
<h1>Proxyquire</h1>
<p><a href="https://github.com/thlorenz/proxyquire">https://github.com/thlorenz/proxyquire</a></p>
<h2>proxyquire 모듈 로드 순서 문제</h2>
<pre><code class="language-bash">src/
    router/
        auth.js
    find-basic-member.js
    app.js
test/
    test.js
</code></pre>
<p><code>app.js</code> -> <code>auth.js</code> -> <code>find-basic-member.js</code> 이와같은 모듈 의존 관계가 있다.</p>
<p>테스트 대상은 <code>app.js</code>.
Mocking 대상은 <code>auth.js</code>가 사용하는 <code>find-basic-member.js</code></p>
<p>사용 방법:</p>
<pre><code class="language-javascript">proxyquire('../src/router/auth', {
    '../find-basic-member': mockFindBasicMember
});
const app = require('../src/app'); // app uses mock find-basic-member
</code></pre>
<p>위 코드가 Mocking 이 되는 이유는
<code>app.js</code> -> <code>auth.js</code>의 <code>require('../find-basic-member')</code>를 호출하더라도
<code>proxyrequire</code>에 의해 캐시된 모듈을 이용하기 때문이다.</p>
<p>nodejs <code>require</code> 또한 캐시된 정보를 사용하기 때문에 여러번 <code>require</code> 해도 실제 파일을 읽는건 한 번 뿐이다.</p>
<p><em>Forcing proxyquire to reload modules</em> 단락 참고: <a href="https://github.com/thlorenz/proxyquire">https://github.com/thlorenz/proxyquire</a></p>
<p>다음과 같이 호출 순서를 변경하면 동작하지 않는다:</p>
<pre><code class="language-javascript">const app = require('../src/app'); // app uses original find-basic-member
proxyquire('../src/router/auth', {
    '../find-basic-member': mockFindBasicMember
});
</code></pre>
<p><code>proxyquire</code>가 <code>app.js</code> -> <code>auth.js</code>의 <code>require('../find-basic-member')</code>를 사용한다.</p>
<h3><code>require('proxyquire').noPreserveCache()</code> 사용하기</h3>
<p>위의 예제처럼 사용한 경우 <code>proxyquire()</code> 이후에 로드하는 모듈은 모두 Mock Module을 사용한다.</p>
<p>따라서 명확하게 Mock Module 의존을 주입할 필요가 있다.</p>
<p><code>noPreserveCache()</code>는 캐시된 모듈을 사용하지 않고 다시 모듈을 로드한다.</p>
<p><code>proxyquire()</code>의 반환은 Mock Module 이다. 이를 이용해 의존성을 직접 주입한다.</p>
<pre><code class="language-javascript">const mockAuth = proxyquire('../src/router/auth', {
    '../find-basic-member': mockFindBasicMember
});
const mockApp = proxyquire('../src/app', {
    './router/auth': mockAuth
});
</code></pre>
<p>의존의 의존을 모두 명시한다.</p>
<h1>Proxyquire vs. rewire</h1>
<p>테스트 할 때 Dependency Injection 하는데 사용하는 도구 2가지 비교.</p>
<p>rewire: <a href="https://github.com/jhnns/rewire">https://github.com/jhnns/rewire</a></p>
<p>rewire는 <em>monkey-patching</em> 도구라고 설명하고 있다.</p>
<p>proxyquire: <a href="https://github.com/thlorenz/proxyquire">https://github.com/thlorenz/proxyquire</a></p>
<p>proxyquire는 의존 모듈을 덮어 쓴다고 설명하고 있다. <em>overriding dependencies</em></p>
<h2>어떤 차이가 있을까?</h2>
<h3>rewire: 테스트 대상 내에 선언한 변수를 가로채어 바꾼다.</h3>
<pre><code class="language-javascript">// app.js
var foo = 1;
module.exports = () => console.log(foo);
</code></pre>
<pre><code class="language-javascript">// test.js
const rewire = require('rewire');
const app = rewire('./app');  // 테스트 대상

app.__set__('foo', 2);

app();  // 2
</code></pre>
<h3>proxyquire: 테스트 대상이 <code>require</code>하는 모듈을 바꿔서 보내준다.</h3>
<pre><code class="language-javascript">// bar.js
module.exports = 1;
</code></pre>
<pre><code class="language-javascript">// app.js
const bar = require('./bar');
module.exports = () => console.log(foo);
</code></pre>
<pre><code class="language-javascript">// test.js
const proxyquire = require('proxyquire');
// 테스트 대상 및 의존 모듈 mocking
const app = proxyquire('./app', {
    './bar': 2
});

app();  // 2
</code></pre>
<h2>rewire 제한사항</h2>
<p>rewire는 <code>const</code>로 선언된 변수는 변경할 수 없었다. 따라서 의존 모듈을 <code>const</code>에 할당하면 stub 할 수 없다.
이 문제 때문에 일단 proxyquire를 사용하고 있다.</p>
<h1>Sinon.JS</h1>
<p>자바스크립트를 위한 테스트 spies, stubs, mocks.</p>
<h2><code>new Date()</code> 조작하기</h2>
<pre><code class="language-javascript">var clock = sinon.useFakeTimers(new Date('1800-01-01 00:00:00'));
console.log(new Date()); // Wed Jan 01 1800 00:00:00 GMT+0900 (KST)
clock.restore();
console.log(new Date()); // now
</code></pre>
<p><code>useFakeTimers()</code>로부터 반환되는 객체의 <code>restore()</code>를 호출하여 조작된 시간을 복구할 수 있다.</p>
<p>주의할 점은 복구하지 않고 다시 조작하는 경우.</p>
<pre><code class="language-javascript">var clock1 = sinon.useFakeTimers(new Date('1800-01-01 00:00:00'));
console.log(new Date()); // Wed Jan 01 1800 00:00:00 GMT+0900 (KST)
var clock2 = sinon.useFakeTimers(new Date('2000-12-01 00:00:00'));
console.log(new Date()); // Fri Dec 01 2000 00:00:00 GMT+0900 (KST)
clock2.restore();
console.log(new Date()); // Wed Jan 01 1800 00:00:00 GMT+0900 (KST)
clock1.restore();
console.log(new Date()); // now
</code></pre>
<p>나중에 조작한 시간을 복구해도 이전에 조작한 시간이 남아 있다.</p>
<p><code>clock1</code>을 바로 복구해도 돌아올 수 있다.</p>
<pre><code class="language-javascript">var clock1 = sinon.useFakeTimers(new Date('1800-01-01 00:00:00'));
console.log(new Date()); // Wed Jan 01 1800 00:00:00 GMT+0900 (KST)
var clock2 = sinon.useFakeTimers(new Date('2000-12-01 00:00:00'));
console.log(new Date()); // Fri Dec 01 2000 00:00:00 GMT+0900 (KST)
clock1.restore();
console.log(new Date()); // now
</code></pre>
<h1>NodeJS data validation</h1>
<p>웹 서버를 작성할 때, 요청 데이터를 수동으로 검증하는 일은 너무 피곤하다.</p>
<p>Python Django는 자체적으로 Form 클래스를 제공한다:<br>
<a href="https://developer.mozilla.org/ko/docs/Learn/Server-side/Django/Forms">https://developer.mozilla.org/ko/docs/Learn/Server-side/Django/Forms</a></p>
<p>Django Form은 정말 다양한 필드를 지원한다.</p>
<p>Python Flask는 WTForm 또는 Marshmallow을 사용한다:</p>
<ul>
<li><a href="https://github.com/wtforms/wtforms">https://github.com/wtforms/wtforms</a></li>
<li><a href="https://github.com/marshmallow-code/marshmallow">https://github.com/marshmallow-code/marshmallow</a></li>
</ul>
<p>WTForm이 경량하게 사용할 수 있었고, Marshmallow는 사용해보지 않았다.
Marshmallow는 Django의 Form과 영속성을 결합한 Model Form과 비슷한 기능을 지원하는 거 같다.</p>
<p>NodeJS는 아직까지 사용해본 적이 없다.
이때까지 수동으로 처리해왔는데 너무 힘들었다.
이런거도 해보려다가 말았다:<br>
<a href="https://github.com/Edunga1/grooming-type-checker">https://github.com/Edunga1/grooming-type-checker</a></p>
<p>expressjs나 다른 프레임워크는 어떻게 처리하는지 찾아보니 Joi를 사용하는가 보다.
Joi는 hapijs의 생태계에서 개발되었다.</p>
<p>hapijs에 종속되지 않아서 어느 곳에서나 사용할 수 있다:</p>
<blockquote>
<p>The most powerful schema description language and data validator for JavaScript.</p>
</blockquote>
<h1>NodeJS 서버 로컬 요청만 허용하기</h1>
<p><a href="https://stackoverflow.com/questions/14043926/node-js-connect-only-works-on-localhost">https://stackoverflow.com/questions/14043926/node-js-connect-only-works-on-localhost</a><br>
여기에서 힌트를 얻었음</p>
<p><a href="https://nodejs.org/api/net.html#net_server_listen_port_host_backlog_callback">https://nodejs.org/api/net.html#net_server_listen_port_host_backlog_callback</a><br>
<code>server.listen()</code> 스펙을 보면 포트 번호와 함께 host(ip)를 입력하면 해당 ip만 허용한다.</p>
<p>기본값은 <code>0.0.0.0</code>이고 '지정되지 않음'을 의미하며 외부 ip의 연결도 허용하지만, <code>127.0.0.1</code>으로 두면 로컬 연결만 허용된다.</p>
<p>근데, 이렇게 로컬 요청을 구분하는 것은 좋지 않은 것으로 보인다.
MSA 환경 구축하면 다른 머신의 연결도 있을테니까.
virtual host 또는 방화벽으로 막는게 합리적으로 보인다.</p>
<h1>pm2 deploy 시 주의할 점</h1>
<p><a href="http://pm2.keymetrics.io/docs/usage/deployment/#complete-tutorial">pm2 deploy tutorial</a>
처럼 <code>post-deploy</code>를 다음과 같이 저장하는 경우 조심해야 한다.</p>
<pre><code class="language-json">"post-deploy": "npm install &#x26;&#x26; pm2 startOrRestart ecosystem.json --env production"
</code></pre>
<p><code>pm2 deploy</code> 하면 다음 절차로 일이 발생한다:</p>
<ol>
<li>로컬 <code>ecosystem.json</code>과 같은 설정 파일을 읽어들임</li>
<li>명세한 서버 정보(<code>user</code>, <code>host</code>)로 리모트 서버에 접속</li>
<li>(리모트 서버에서) git pull</li>
<li>(리모트 서버에서) npm install</li>
<li>(리모트 서버에서) pm2 startOrRestart ecosystem.json --env production</li>
<li>(리모트 서버에서) 위 명령어에 의한 <code>ecosystem.json</code> 설정 파일을 읽어들임</li>
<li><code>apps</code> 명세에 따른 배포</li>
</ol>
<p>그러니까 설정 파일은 로컬에서, 리모트에서 총 2번 읽어들인다.</p>
<p>그래서 pm2는 현재 브랜치가 트래킹 중인 리모트 브랜치와 달라지면 싱크를 맞추라고 한다: <code>push your changes before deploying</code></p>
<p>로컬이랑 서버랑 설정 파일이 안맞으면 골치아파진다. 서로 다른 설정 파일을 읽기 때문에 원하는 대로 작업이 이루어지지 않을 수도 있다.
원인은 로컬에서 실행되는 명령어의 명세인 <code>deploy</code>, 리모트 서버에서 실행되는 명령어의 명세인 <code>apps</code>를 보통 하나의 파일에서 관리하고
코드베이스에 포함하기 때문인데, 설정 파일을 다른 위치에 두면 로컬과 리모트의 설정 파일의 싱크를 보장할 수 없다.</p>
<hr>
<p>pm2로 배포 프로세스를 관리하고 싶어서 설정 파일을 작성하였으나, 데이터베이스 비밀번호를 <code>env</code>에 저장하면 코드베이스에 포함되기 때문에,
다른 repository로 분리하려 했다.</p>
<p>그래서 <code>npm run deploy</code>하면 셸 스크립트를 실행하도록 했다:</p>
<ol>
<li>pm2 설정 파일을 가지는 저장소<code>git clone git@github.com:user/repo.git .config</code></li>
<li><code>pm2 deploy .config/ecosystem.json production</code></li>
</ol>
<p>리모트 서버에는 <code>config</code> 저장소를 하나 클론 받아놓고 적절한 곳에 두고
<code>post-deploy</code>를 <code>"npm install &#x26;&#x26; pm2 startOrRestart /home/node/config/ecosystem.json --env production"</code>
설정 파일의 위치를 해당 위치를 가리키도록 했다.</p>
<p>이러다보니 설정 정보를 업데이트해도 리모트에서 다시 pull 하지 않으면 로컬에서는 최신 설정을, 리모트에서는 이전 설정을 사용하는 문제가 있다.</p>
<p>따라서 리모트에서도 항상 <code>config</code> 저장소를 clone 후 <code>pm2 startOrRestart</code> 하도록 해야겠다.</p>
<h1>Jupyter notebook 사용하기</h1>
<p>[Jupyter Docker Stacks](docker#Jupyter Docker Stacks)</p>
<h1>Taming architecture complexity in v8</h1>
<p><a href="https://theori.io/research/korean/taming-architecture-complexity-in-v8">https://theori.io/research/korean/taming-architecture-complexity-in-v8</a></p>
<p><a href="https://v8.dev/blog/csa">원문</a>을 번역한 글.</p>
<p>옛날엔 내장 함수(builtin)가 self-hosted, JS로 작성되기도 했다.
그러다보니 성능 이슈가 있었고, 어셈블리로 다시 작성되었다.</p>
<p>성능은 향상되었으나, 유지보수를 하는데 어려워졌다.</p>
<p>그래서 어셈블리어로 변환해주는 중간 계층을 두었다.
프레임워크처럼 C++ 매크로로 틀에 맞춰 작성하면,
어셈블리 코드로 변환된다.</p>
<p>테스트코드 또한 C++로 작성할 수 있다.</p>
<p>문자열 객체에 길이를 구하는 <code>GetStringLength</code> 함수를 작성하는
자세한 예시를 보여주니 좋다.</p>
<p>작성한 C++ 코드의 가독성이 좋아 보인다:</p>
<pre><code class="language-cpp">TF_BUILTIN(GetStringLength, CodeStubAssembler) {
    Label not_string(this);

    Node* const maybe_string = Parameter(Descriptor::kInputObject);

    GotoIf(TaggedIsSmi(maybe_string), &#x26;not_string);

    GotoIfNot(IsString(maybe_string), &#x26;not_string);

    Return(LoadStringLength(maybe_string));

    BIND(&#x26;not_string);

    Return(UndefinedConstant());
}
</code></pre>
<p><a href="https://medium.com/swlh/1-powerful-way-to-write-robust-code-7c650071fe6b">견고한 코드를 작성하는 방법</a>
글이 생각났다. 진입점은 깔끔하게 유지하기.</p></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/wiki/2bdb063c-7f09-56d1-9ff8-f046eef2e1b6/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-81fc23a5f8ac4aaeaf7f.js\"],\"component---src-pages-404-tsx\":[\"/component---src-pages-404-tsx-7bfef5ca48decc695459.js\"],\"component---src-pages-index-tsx\":[\"/component---src-pages-index-tsx-f35ba86948279f201a97.js\"],\"component---src-pages-wiki-markdown-remark-id-tsx\":[\"/component---src-pages-wiki-markdown-remark-id-tsx-b2b1547370b411798096.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="ce0ca80b8bbb8fe37f68";</script><script src="/webpack-runtime-cd7f39db9de2bf679569.js" async></script><script src="/framework-9b6d338de49a676a1843.js" async></script><script src="/app-81fc23a5f8ac4aaeaf7f.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>
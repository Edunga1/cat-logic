<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 5.6.0"/><style type="text/css">
    .anchor.before {
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-100%);
      padding-right: 4px;
    }
    .anchor.after {
      display: inline-block;
      padding-left: 4px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg,
    h1 .anchor:focus svg,
    h2 .anchor:focus svg,
    h3 .anchor:focus svg,
    h4 .anchor:focus svg,
    h5 .anchor:focus svg,
    h6 .anchor:focus svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = window.decodeURI(location.hash.replace('#', ''))
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
          var clientTop = document.documentElement.clientTop || document.body.clientTop || 0
          var offset = element.getBoundingClientRect().top + scrollTop - clientTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><style data-styled="" data-styled-version="5.3.6">.gVurN{display:grid;grid-template-columns:minmax(300px,1fr) minmax(400px,1000px);width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;}/*!sc*/
@media (max-width:1000px){.gVurN{grid-template-columns:1fr;}.gVurN > div:nth-child(1){display:none;}}/*!sc*/
data-styled.g1[id="markdownRemarkfields__slug__Container-sc-cg714z-0"]{content:"gVurN,"}/*!sc*/
.lgmMAy{margin:4rem 2rem 0 0;}/*!sc*/
.lgmMAy ul{list-style:none;}/*!sc*/
.lgmMAy ul p{margin:0;}/*!sc*/
.lgmMAy a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g2[id="markdownRemarkfields__slug__Toc-sc-cg714z-1"]{content:"lgmMAy,"}/*!sc*/
.eSmnmE a{-webkit-text-decoration:none;text-decoration:none;}/*!sc*/
data-styled.g3[id="markdownRemarkfields__slug__Content-sc-cg714z-2"]{content:"eSmnmE,"}/*!sc*/
</style></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="markdownRemarkfields__slug__Container-sc-cg714z-0 gVurN"><div class="markdownRemarkfields__slug__Toc-sc-cg714z-1 lgmMAy"><ul>
<li>
<p><a href="#design-pattern">Design Pattern</a></p>
</li>
<li>
<p><a href="#iterator-pattern">Iterator Pattern</a></p>
</li>
<li>
<p><a href="#repository-pattern">Repository Pattern</a></p>
<ul>
<li><a href="#generic-repository-vs-specific-repository">Generic Repository vs. Specific Repository</a></li>
</ul>
</li>
<li>
<p><a href="#state-pattern-and-state-machine">state pattern and state machine</a></p>
<ul>
<li>
<p><a href="#state-pattern">state pattern</a></p>
</li>
<li>
<p><a href="#state-machine">state machine</a></p>
<ul>
<li>
<p><a href="#%EA%B5%AC%ED%98%84%EC%B2%B4">구현체</a></p>
<ul>
<li><a href="#spring">Spring</a></li>
<li><a href="#pytohn">Pytohn</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#references">references</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#strategy-pattern">Strategy Pattern</a></p>
</li>
<li>
<p><a href="#mvc-pattern">MVC Pattern</a></p>
<ul>
<li>
<p><a href="#mvc-%ED%8C%A8%ED%84%B4%EC%9D%98-%EB%AA%A9%EC%A0%81%EA%B3%BC-%EC%9D%B4%EC%A0%90">MVC 패턴의 목적과 이점</a></p>
</li>
<li>
<p><a href="#compound-pattern">Compound Pattern</a></p>
<ul>
<li><a href="#1-observer-pattern">1. Observer Pattern</a></li>
<li><a href="#2-strategy-pattern">2. Strategy Pattern</a></li>
<li><a href="#3-composite-pattern">3. Composite Pattern</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#%EC%B0%B8%EC%A1%B0">참조</a></p>
</li>
</ul></div><div class="markdownRemarkfields__slug__Content-sc-cg714z-2 eSmnmE"><h1 id="design-pattern" style="position:relative;"><a href="#design-pattern" aria-label="design pattern permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Pattern</h1>
<h1 id="iterator-pattern" style="position:relative;"><a href="#iterator-pattern" aria-label="iterator pattern permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Iterator Pattern</h1>
<p>다양한 Collection을 일관적인 방법으로 순회할 수 있도록 함</p>
<p><img src="res/dp-iterator.gif" alt="uml-iterator"></p>
<p>Java의 경우 ArrayList, Vector, LinkedList와 같은 컬렉션 클래스들은 java.util.Iterator를 구현하여
iterator() 메소드를 통해 iterator를 반환 해 준다.</p>
<p>일반 배열을 사용한 경우 Iterator 인터페이스를 구현한 Concrete Iterator를 만들어서 사용하면 된다.</p>
<h1 id="repository-pattern" style="position:relative;"><a href="#repository-pattern" aria-label="repository pattern permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Repository Pattern</h1>
<p>도메인 로직에서 저장소에 접근하기 위해서 쿼리를 전송하는 것은 좋지 않다. 특정 데이터베이스에 종속된다.
RDBMS도 MySQL, MsSQL, Oracle 다 쿼리 스펙이 다르다. 그래서 데이터 소스(DB)와 커뮤니케이션할 추상 레이어를 둔다.
데이터베이스의 변경 여지가 있기 때문에 추상화하기도 한다. MySQL -> MsSQL 전환, RDBMS -> NoSQL로의 전환도 언젠가 할지도 모른다.</p>
<p>물론 DB 전환을 염두하고 추상화하지 말라는 뉘앙스의 글도 있다: <a href="../programming-paradigm">"Database Abstraction Layers Must Die!"라는 글을 읽고</a></p>
<p>아무튼. Repository Pattern은 데이터의 중앙화와 API의 일관성을 유지하고 중복 코드를 제거해 준다.</p>
<p><a href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ff649690(v=pandp.10)">MSDN의 Repository Pattern</a>을 번역한 글:<br>
<a href="http://vandbt.tistory.com/27">http://vandbt.tistory.com/27</a></p>
<p>개념적인 글이라서 코드가 있는 MSDN 글과 보면 좋다:<br>
<a href="https://docs.microsoft.com/ko-kr/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application">https://docs.microsoft.com/ko-kr/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application</a></p>
<p>UnitOfWork 패턴까지 이어지는 글이다.</p>
<p>Repository Pattern에는 두 종류가 있다. Generic Repository와 Specific Repository</p>
<p>코드 중복을 제거하고 일관성 유지를 강조하는 Generic Repository와 유연성을 강조하는 Specific Repository.</p>
<h2 id="generic-repository-vs-specific-repository" style="position:relative;"><a href="#generic-repository-vs-specific-repository" aria-label="generic repository vs specific repository permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generic Repository vs. Specific Repository</h2>
<p><a href="https://stackoverflow.com/questions/1230571/advantage-of-creating-a-generic-repository-vs-specific-repository-for-each-obje">https://stackoverflow.com/questions/1230571/advantage-of-creating-a-generic-repository-vs-specific-repository-for-each-obje</a></p>
<ul>
<li>점수를 많이 받은 답은 <strong>Specific Repository를 더 선호한다</strong>. 그 이유는 아래와 같다.</li>
<li>모든 엔티티가 저장소를 가지는 것은 아니기 때문이다.</li>
<li>하지만 베이스 레포지토리 (abstract class)는 사용한다.</li>
<li>a repository is a part of the domain being modeled, and that domain is not generic. Not every entity can be deleted, not every entity can be added, not every entity has a repository<br></li>
</ul>
<p>레포지토리는 모델링 되는 도메인의 일부분이며, 그 도메인은 generic 하지 않다. 모든 엔티티가 삭제되거나 추가되는 것이 아니며, 모든 엔티티가 레파지토리를 가지는 것은 아니다.</p>
<p><strong>Generic Repository?</strong></p>
<ul>
<li>Repository를 규격화 한다.</li>
<li><code>Repository&#x3C;User></code>, <code>Repository&#x3C;Comment></code> 처럼 Entity 클래스를 Generic Type으로 받는다.</li>
<li>장점으로 모든 Repository는 일관된 인터페이스를 가진다.</li>
</ul>
<p><strong>Specific Repository?</strong></p>
<ul>
<li>Repository를 테이블마다 구현한다.
<ul>
<li>UserRepository, CommentRepository</li>
</ul>
</li>
<li>CRUD 뿐만 아니라 테이블별 각각 다른 메소드를 구현할 수 있다.
<ul>
<li>UserRepository.addUser, CommentRepository.deleteShortComment 처럼..</li>
</ul>
</li>
<li>코드 양은 많아 지겠지만 Generic 보다 더 유연할 듯하다.</li>
</ul>
<p><strong>생각해 본 것들:</strong></p>
<p><strong>대표적으로 C#의 Entity Framework. 대부분 DB 프레임워크는 어노테이션을 이용한다.</strong></p>
<pre><code class="language-csharp">public class Blog
{
    [Key]
    public int PrimaryTrackingKey { get; set; }
    public string Title { get; set; }
    public string BloggerName { get; set;}
    public virtual ICollection&#x3C;Post> Posts { get; set; }
}
</code></pre>
<p>내가 위 코드를 동작케 한다면 다음과 같은 규칙을 가질 것이다:</p>
<ol>
<li>프로퍼티 이름 = 테이블 컬럼 이름</li>
<li><code>[Key]</code> 어노테이션은 Primary Key가 되는데, 데이터베이스 PK, Unique, Auto increment 속성을 가진다.</li>
<li>언어의 타입 int, string 등을 데이터베이스 타입에 적절히 매핑해야 함</li>
</ol>
<p>만약 어노테이션을 사용하지 않고, 자바스크립트로 구현한다면?</p>
<ol>
<li>프로퍼티 이름 = 테이블 컬럼 이름은 가능</li>
<li>PK가 될 컬럼(프로퍼티)는 어떻게?</li>
<li>타입은 어떻게 하나.</li>
</ol>
<p>위 문제를 해결하기 위해서 static 변수에 pk, type 등 정보를 저장해야 할 거 같다.</p>
<p><strong>Specific Repository를 구현한다면 어노테이션 없이도 복잡하지 않게 구현할 수 있을 거 같다.</strong></p>
<p>각 메서드에서 쿼리를 만들 거고(쿼리 빌더를 쓰던간에), 어노테이션 없는 Entity 클래스도 만들 수 있다!</p>
<h1 id="state-pattern-and-state-machine" style="position:relative;"><a href="#state-pattern-and-state-machine" aria-label="state pattern and state machine permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>state pattern and state machine</h1>
<p>공통점은 많은 상태들 사이에서 같은 이벤트가 발생했을 때 다음 상태로 전이하는 것이다.</p>
<p>다른 점은 어디에 집중하느냐 인데, state pattern은 이벤트에 따른 행동에, state machine은 상태 관리라고 생각한다.</p>
<h2 id="state-pattern" style="position:relative;"><a href="#state-pattern" aria-label="state pattern permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>state pattern</h2>
<ul>
<li>behavior의 구현에서 다음 상태를 결정하기 때문에, dynamic target 상태를 가진다.</li>
<li>OOP로 구현하면 각 상태에 해당하는 concrete class가 존재한다.</li>
<li>따라서 많은 상태와 행동이 있으면 관리하기 어렵다.</li>
</ul>
<h2 id="state-machine" style="position:relative;"><a href="#state-machine" aria-label="state machine permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>state machine</h2>
<ul>
<li>상태와 이벤트 조합으로 다음 상태(target)로 변화하는 transition을 한 곳에서 관리한다. 그래서 추적하기 쉽다.</li>
<li>OOP로 구현하면 모든 상태를 관리하는 state machine로 일반화 했기 때문에 좀 더 간단하다.</li>
<li>하지만 일반화 했기 때문에 이벤트마다 달라지는 부분을 구현하기에 까다롭다.</li>
</ul>
<h3 id="구현체" style="position:relative;"><a href="#%EA%B5%AC%ED%98%84%EC%B2%B4" aria-label="구현체 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>구현체</h3>
<h4 id="spring" style="position:relative;"><a href="#spring" aria-label="spring permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Spring</h4>
<p><a href="https://docs.spring.io/spring-statemachine/docs/1.1.1.RELEASE/reference/htmlsingle/">https://docs.spring.io/spring-statemachine/docs/1.1.1.RELEASE/reference/htmlsingle/</a></p>
<p>빌더 패턴으로 상태와 이벤트와 다음 상태를 구성한다.</p>
<p>상태와 하위 상태까지 구성 가능하다.</p>
<h4 id="pytohn" style="position:relative;"><a href="#pytohn" aria-label="pytohn permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pytohn</h4>
<p><a href="https://github.com/pytransitions/transitions">https://github.com/pytransitions/transitions</a></p>
<h2 id="references" style="position:relative;"><a href="#references" aria-label="references permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>references</h2>
<p><a href="https://stackoverflow.com/questions/19859531/what-is-the-difference-between-a-state-machine-and-the-implementation-of-the-sta">https://stackoverflow.com/questions/19859531/what-is-the-difference-between-a-state-machine-and-the-implementation-of-the-sta</a></p>
<p>답변자 말로는, state pattern은 분산된 구조이고, state machine은 모놀리틱 구조라 한다.</p>
<h1 id="strategy-pattern" style="position:relative;"><a href="#strategy-pattern" aria-label="strategy pattern permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Strategy Pattern</h1>
<p><a href="https://refactoring.guru/ko/design-patterns/strategy">refactoring.guru</a>중에서:</p>
<blockquote>
<ol start="4">
<li>콘텍스트 클래스에서 전략 객체에 대한 참조를 저장하기 위한 필드를 추가한 후, 해당 필드의 값을 대체하기 위한 세터를 제공하세요. 콘텍스트는 전략 인터페이스를 통해서만 전략 객체와 작동해야 합니다. 콘텍스트는 인터페이스를 정의할 수 있으며, 이 인터페이스는 전략이 콘텍스트의 데이터에 접근할 수 있도록 합니다.</li>
</ol>
</blockquote>
<p>간단히 전략 객체 내에서 print만하는 예제들이 놓치는 부분이다.</p>
<p>전략 객체는 context가 제공하는 메서드를 사용하여 context를 변경해야한다.
전략 객체의 메서드에서 파라미터로 받거나, 생성자로 받거나 할 필요가 없다.</p>
<h1 id="mvc-pattern" style="position:relative;"><a href="#mvc-pattern" aria-label="mvc pattern permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MVC Pattern</h1>
<p>Model - View - Controller Pattern.</p>
<h2 id="mvc-패턴의-목적과-이점" style="position:relative;"><a href="#mvc-%ED%8C%A8%ED%84%B4%EC%9D%98-%EB%AA%A9%EC%A0%81%EA%B3%BC-%EC%9D%B4%EC%A0%90" aria-label="mvc 패턴의 목적과 이점 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MVC 패턴의 목적과 이점</h2>
<p>MVC 패턴는 사용자 인터페이스와 시스템 로직을 분리하는 것을 목적으로 둔다.</p>
<p>분리함으로써 얻는 이점은 다른 환경에서 재사용 할 수 있는 코드가 생기는 것이다.</p>
<p>예를들어 C# 윈도우 어플리케이션에 종속되는 유저 인터페이스 관련 코드들과 시스템이 돌아가는데
필요한 코드(model)를 분리함으로써 다른 플랫폼으로 이식할 수 있다.</p>
<h2 id="compound-pattern" style="position:relative;"><a href="#compound-pattern" aria-label="compound pattern permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Compound Pattern</h2>
<p>MVC 패턴은 다른 디자인 패턴으로 이루어진 컴파운드 패턴이다.</p>
<h3 id="1-observer-pattern" style="position:relative;"><a href="#1-observer-pattern" aria-label="1 observer pattern permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. Observer Pattern</h3>
<p>Model - View의 관계</p>
<p>유저 인터페이스와 시스템 로직을 분리할 수 있게 해주는 핵심 패턴으로 모델은 상태 변경이 일어나면
뷰에 상태 변경을 통보한다.</p>
<p>그러면 뷰는 모델에서 필요한 정보들을 가져와 사용자 화면을 업데이트 한다.</p>
<p>모델이 뷰에 통보할 때 상태 정보를 보내주는 push-model 보다
통보 후 뷰가 필요한 정보를 알아서 가져가는 pull-model이 더 선호된다.</p>
<h3 id="2-strategy-pattern" style="position:relative;"><a href="#2-strategy-pattern" aria-label="2 strategy pattern permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. Strategy Pattern</h3>
<p>View - Controller의 관계</p>
<p>Controller는 View에 대한 Behavior가 된다.</p>
<p>같은 View라고 하더라도 Controller를 변경함으로써 다르게 실행되도록 할 수 있다.</p>
<p>따라서 View에 Concrete Controller가 아닌 Interface Controller를 제공한다.</p>
<h3 id="3-composite-pattern" style="position:relative;"><a href="#3-composite-pattern" aria-label="3 composite pattern permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. Composite Pattern</h3>
<p>View 내에서 Component들 간의 관계</p>
<p>일반적으로 사용자 인터페이스의 컴포넌트들은 컴포넌트 안에 컴포넌트로 표현한다.</p>
<p>이 컴포넌트들을 iterator를 통해 일관성있게 접근하여 업데이트 시킨다.</p>
<h1 id="참조" style="position:relative;"><a href="#%EC%B0%B8%EC%A1%B0" aria-label="참조 permalink" class="anchor before"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>참조</h1>
<ul>
<li><a href="https://refactoring.guru/ko/design-patterns/">refactoring.guru</a> - 무료 공개 ebook</li>
</ul></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/wiki/design-pattern/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-c3df7cc128b1fd8badc3.js\"],\"component---src-pages-404-tsx\":[\"/component---src-pages-404-tsx-7bfef5ca48decc695459.js\"],\"component---src-pages-index-tsx\":[\"/component---src-pages-index-tsx-a6d255ad0e2dec90f2a0.js\"],\"component---src-pages-wiki-markdown-remark-fields-slug-tsx\":[\"/component---src-pages-wiki-markdown-remark-fields-slug-tsx-53b614638ada36bb99f1.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="e8158fe77303107b8eb0";</script><script src="/webpack-runtime-38d5c81004aa5979d0dd.js" async></script><script src="/framework-9b6d338de49a676a1843.js" async></script><script src="/app-c3df7cc128b1fd8badc3.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>